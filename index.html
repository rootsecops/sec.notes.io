<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEC0_C++</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
            line-height: 1.6;
        }
        .container {
            max-width: 960px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        .header {
            background-color: #ffffff;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .section-card {
            background-color: #ffffff;
            padding: 2rem;
            margin-bottom: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3, h4 {
            color: #1e293b;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        h1 { font-size: 2.25rem; }
        h2 { font-size: 1.875rem; }
        h3 { font-size: 1.5rem; }
        h4 { font-size: 1.25rem; }
        p {
            margin-bottom: 1rem;
        }
        ul {
            list-style-type: disc;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }
        ol {
            list-style-type: decimal;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        th, td {
            border: 1px solid #cbd5e1;
            padding: 0.75rem;
            text-align: left;
        }
        th {
            background-color: #e2e8f0;
            font-weight: 600;
            color: #475569;
        }
        .hamburger-icon {
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            width: 30px;
            height: 25px;
            background: transparent;
            border: none;
            padding: 0;
            z-index: 1001;
        }
        .hamburger-icon span {
            display: block;
            width: 100%;
            height: 3px;
            background-color: #334155;
            border-radius: 2px;
            transition: all 0.3s ease-in-out;
        }
        .hamburger-icon.open span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        .hamburger-icon.open span:nth-child(2) {
            opacity: 0;
        }
        .hamburger-icon.open span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .overlay.open {
            opacity: 1;
            visibility: visible;
        }
        .overlay-menu {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 90%;
            max-width: 400px;
        }
        .overlay-menu a {
            display: block;
            padding: 0.75rem 0;
            color: #334155;
            font-size: 1.25rem;
            text-decoration: none;
            border-bottom: 1px solid #e2e8f0;
            transition: background-color 0.2s ease-in-out;
        }
        .overlay-menu a:last-child {
            border-bottom: none;
        }
        .overlay-menu a:hover {
            background-color: #f8fafc;
            border-radius: 0.25rem;
        }
        .overlay-menu a.active {
            font-weight: 700;
            color: #2563eb;
        }
        pre {
            background-color: #f4f4f4;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-bottom: 1rem;
        }
        code {
            font-family: 'Fira Code', monospace; /* Using a monospace font for code */
            font-size: 0.9rem;
            color: #333;
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .container {
                padding: 2rem;
            }
            .header {
                padding: 1.5rem 2rem;
            }
            .section-card {
                padding: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="text-2xl md:text-3xl font-bold">C++ Fundamentals</h1>
        <button class="hamburger-icon" id="hamburger-icon" aria-label="Open navigation menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
    </div>

    <div class="overlay" id="overlay">
        <div class="overlay-menu">
            <a href="#unit-1" onclick="closeOverlay()">Unit 1: C++ Fundamentals</a>
            <a href="#unit-2" onclick="closeOverlay()">Unit 2: Writing a Program in C++</a>
            <a href="#unit-3" onclick="closeOverlay()">Unit 3: Control Statements</a>
            <a href="#unit-4" onclick="closeOverlay()">Unit 4: Functions & Program Structures</a>
            <a href="#unit-5" onclick="closeOverlay()">Unit 5: Arrays</a>
            <a href="#unit-6" onclick="closeOverlay()">Unit 6: Character Handling & Strings</a>
            <a href="#unit-7" onclick="closeOverlay()">Unit 7: Structures & Unions</a>
            <a href="#unit-8" onclick="closeOverlay()">Unit 8: Data File Handling</a>
            <a href="#unit-9" onclick="closeOverlay()">Unit 9: Objects & Classes</a>
        </div>
    </div>

    <div class="container">
        <section id="unit-1" class="section-card">
            <h2 class="text-xl md:text-2xl">Unit 1: C++ Fundamentals Overview</h2>
            <p>The syllabus for Unit-1 focuses on essential C++ programming concepts, providing a strong foundation for beginners. It includes understanding the C++ character set, which defines usable characters, and data types that specify variable data. It also covers identifiers and keywords for naming, variable declaration and initialization, constants for fixed values, a wide range of operators for operations, and type conversion for data type changes.</p>

            <h3 class="text-lg md:text-xl">Detailed Explanation</h3>
            <ul class="list-disc ml-6">
                <li><strong>Character Set</strong>: The C++ character set includes letters, digits, punctuation, and control characters, essential for forming program elements.</li>
                <li><strong>Data Types</strong>: These define the type of data a variable can hold, such as integers, floats, and booleans, with specific sizes and ranges.</li>
                <li><strong>Identifiers and Keywords</strong>: Identifiers are user-defined names, while keywords are reserved words with special meanings, crucial for coding structure.</li>
                <li><strong>Variables</strong>: Involves declaring and initializing variables, which are named memory locations for storing data.</li>
                <li><strong>Constants</strong>: Fixed values like numbers, characters, and strings that cannot change during program execution.</li>
                <li><strong>Operators</strong>: Include arithmetic, assignment, increment/decrement, comparison, logical, bitwise, and special operators for various operations.</li>
                <li><strong>Type Conversion</strong>: The process of converting one data type to another, either implicitly by the compiler or explicitly by the programmer.</li>
            </ul>
            <p>This overview ensures a comprehensive understanding of the syllabus, preparing learners for practical C++ programming.</p>

            <hr class="my-6 border-t border-gray-300">

            <h2 class="text-xl md:text-2xl">Detailed Survey Note on Unit-1: Data Types, Variables, Operators, and Statements in C++</h2>
            <p>This comprehensive note delves into the topics outlined in Unit-1 of the C++ syllabus, covering Data Types, Variables, Operators, and Statements. It provides an in-depth exploration of each concept, ensuring a thorough understanding for learners and programmers. The following sections detail the C++ character set, data types, identifiers and keywords, variables (declaration and initialization), constants (string, numeric, and character), operators (arithmetic, assignment, increment and decrement, comparison/relational, logical, bitwise, and special), and type conversion.</p>

            <h3 class="text-lg md:text-xl">1. C++ Character Set</h3>
            <p>The C++ character set is the collection of characters that can be used within a C++ program. It forms the basis for creating identifiers, keywords, and literals. The character set includes:</p>
            <ul class="list-disc ml-6">
                <li><strong>Basic Character Set</strong>: Comprises 96 characters (until C++26) and 99 characters (since C++26), including:
                    <ul class="list-circle ml-6">
                        <li>Letters: A-Z, a-z</li>
                        <li>Digits: 0-9</li>
                        <li>Punctuation marks: !, @, #, $, %, ^, &, *, (, ), -, +, =, [, ], {, }, ;, :, ', ", \, /, ?, `, ~</li>
                        <li>White spaces: Space, horizontal tab, carriage return, newline, form feed</li>
                    </ul>
                </li>
                <li><strong>Extended Character Set</strong>: Includes additional characters based on the system's character encoding, such as ASCII or UTF-8.</li>
                <li><strong>Special Characters</strong>: Symbols like +, -, *, /, =, &lt;, &gt;, !, &, |, ^, ~, etc., used in expressions and operations.</li>
                <li><strong>Control Characters</strong>: Represented using escape sequences, such as \n for newline and \t for tab, essential for formatting output.</li>
            </ul>
            <p>The character set is crucial for ensuring compatibility and readability in C++ programs, as it defines what characters can be used in source code.</p>

            <h3 class="text-lg md:text-xl">2. Concept of Data Types</h3>
            <p>Data types in C++ specify the type of data that a variable can hold, determining its size, range, and the operations that can be performed on it. C++ supports several fundamental data types, categorized as follows:</p>
            <ul class="list-disc ml-6">
                <li><strong>Integer Types</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>char</code>: Typically 1 byte, range depends on signedness (signed: -128 to 127, unsigned: 0 to 255)</li>
                        <li><code>short</code>: 2 bytes, range: -32768 to 32767 (signed), 0 to 65535 (unsigned)</li>
                        <li><code>int</code>: 4 bytes, range: -2147483648 to 2147483647 (signed), 0 to 4294967295 (unsigned)</li>
                        <li><code>long</code>: 4 or 8 bytes (system-dependent), range varies by system</li>
                        <li><code>long long</code>: 8 bytes, range: -9223372036854775808 to 9223372036854775807 (signed), 0 to 18446744073709551615 (unsigned)</li>
                    </ul>
                </li>
                <li><strong>Floating-Point Types</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>float</code>: 4 bytes, range: approximately 1.2E-38 to 3.4E38</li>
                        <li><code>double</code>: 8 bytes, range: approximately 2.3E-308 to 1.7E308</li>
                        <li><code>long double</code>: 10 or 16 bytes (system-dependent), range depends on the system</li>
                    </ul>
                </li>
                <li><strong>Boolean Type</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>bool</code>: 1 byte, values: true or false, used for logical operations</li>
                    </ul>
                </li>
                <li><strong>Void Type</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>void</code>: No size, used as a placeholder, often for functions that do not return a value</li>
                    </ul>
                </li>
            </ul>
            <p>These data types are essential for declaring variables and ensuring proper memory allocation. The size and range may vary slightly depending on the compiler and system architecture (32-bit or 64-bit).</p>

            <h3 class="text-lg md:text-xl">3. Identifiers and Keywords</h3>
            <ul class="list-disc ml-6">
                <li><strong>Identifiers</strong>:
                    <ul class="list-circle ml-6">
                        <li>Identifiers are names given to variables, functions, classes, and other user-defined entities by the programmer.</li>
                        <li>Rules for identifiers:
                            <ul class="list-square ml-6">
                                <li>Must start with a letter (a-z, A-Z) or an underscore (_).</li>
                                <li>Can contain letters, digits (0-9), and underscores.</li>
                                <li>Cannot start with a digit.</li>
                                <li>Are case-sensitive (e.g., <code>variable</code> and <code>Variable</code> are distinct).</li>
                                <li>Cannot be the same as a keyword.</li>
                                <li>Have no length limit, though practical limits exist for readability.</li>
                            </ul>
                        </li>
                        <li>Example: <code>myVariable</code>, <code>_count</code>, <code>userName</code></li>
                    </ul>
                </li>
                <li><strong>Keywords</strong>:
                    <ul class="list-circle ml-6">
                        <li>Keywords are reserved words in C++ with special meanings, and they cannot be used as identifiers.</li>
                        <li>As of C++23, there are 92 keywords, including <code>int</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>bool</code>, <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>class</code>, <code>namespace</code>, etc.</li>
                        <li>Keywords are case-sensitive and must be written in lowercase (e.g., <code>int</code>, not <code>INT</code>).</li>
                        <li>Example usage: <code>int age;</code> where <code>int</code> is a keyword indicating the data type.</li>
                    </ul>
                </li>
            </ul>
            <p>Identifiers and keywords are fundamental for structuring and naming elements in C++ programs, ensuring clarity and adherence to language rules.</p>

            <h3 class="text-lg md:text-xl">4. Variables (Declaration and Initialization)</h3>
            <p>Variables are named memory locations used to store data that can be accessed and manipulated during program execution.</p>
            <ul class="list-disc ml-6">
                <li><strong>Variable Declaration</strong>:
                    <ul class="list-circle ml-6">
                        <li>Declaration specifies the type and name of the variable, reserving memory for it.</li>
                        <li>Syntax: <code>data_type variable_name;</code></li>
                        <li>Example: <code>int age;</code></li>
                        <li>Variables must be declared before use, informing the compiler of their existence and type.</li>
                    </ul>
                </li>
                <li><strong>Variable Initialization</strong>:
                    <ul class="list-circle ml-6">
                        <li>Initialization assigns an initial value to the variable.</li>
                        <li>Syntax: <code>data_type variable_name = initial_value;</code> or <code>data_type variable_name(initial_value);</code> or <code>data_type variable_name{initial_value};</code> (C++11 uniform initialization)</li>
                        <li>Example: <code>int age = 25;</code>, <code>int age(25);</code>, or <code>int age{25};</code></li>
                        <li>If not initialized, variables may contain indeterminate (garbage) values, leading to undefined behavior.</li>
                    </ul>
                </li>
                <li><strong>Types of Initialization</strong>:
                    <ul class="list-circle ml-6">
                        <li><strong>Default Initialization</strong>: No initializer provided; may result in garbage values.</li>
                        <li><strong>Copy Initialization</strong>: Uses <code>=</code>, e.g., <code>int x = 10;</code></li>
                        <li><strong>Direct Initialization</strong>: Uses parentheses, e.g., <code>int x(10);</code></li>
                        <li><strong>Uniform Initialization (C++11)</strong>: Uses braces, e.g., <code>int x{10};</code>, preferred for avoiding narrowing conversions.</li>
                    </ul>
                </li>
            </ul>
            <p>Variables are the building blocks of C++ programs, enabling data storage and manipulation, with proper initialization ensuring predictable behavior.</p>

            <h3 class="text-lg md:text-xl">5. Constants</h3>
            <p>Constants are fixed values that cannot be modified during program execution. They are categorized into numeric, character, and string constants:</p>
            <ul class="list-disc ml-6">
                <li><strong>Numeric Constants</strong>:
                    <ul class="list-circle ml-6">
                        <li><strong>Integer Constants</strong>: Whole numbers, can be decimal, octal, or hexadecimal.
                            <ul class="list-square ml-6">
                                <li>Decimal: e.g., <code>123</code></li>
                                <li>Octal: e.g., <code>0123</code> (prefix <code>0</code>)</li>
                                <li>Hexadecimal: e.g., <code>0x1A</code> (prefix <code>0x</code>)</li>
                            </ul>
                        </li>
                        <li><strong>Floating-Point Constants</strong>: Numbers with decimal points, e.g., <code>3.14</code>, <code>1.23e2</code> (scientific notation).</li>
                    </ul>
                </li>
                <li><strong>Character Constants</strong>:
                    <ul class="list-circle ml-6">
                        <li>Single character enclosed in single quotes, e.g., <code>'A'</code>, <code>'1'</code>, <code>'+'</code></li>
                        <li>Can include escape sequences, e.g., <code>'\n'</code> for newline, <code>'\t'</code> for tab</li>
                        <li>ASCII values can be represented, e.g., <code>'\x41'</code> for <code>'A'</code></li>
                    </ul>
                </li>
                <li><strong>String Constants</strong>:
                    <ul class="list-circle ml-6">
                        <li>Sequence of characters enclosed in double quotes, e.g., <code>"Hello"</code></li>
                        <li>Can include escape sequences, e.g., <code>"Hello\nWorld"</code></li>
                        <li>String literals are null-terminated arrays of characters, e.g., <code>"Hello"</code> is stored as <code>H, e, l, l, o, \0</code></li>
                    </ul>
                </li>
            </ul>
            <p>Constants are declared using the <code>const</code> keyword, e.g., <code>const int MAX_VALUE = 100;</code>, ensuring immutability and enhancing code reliability.</p>

            <h3 class="text-lg md:text-xl">6. Operators</h3>
            <p>Operators in C++ perform operations on operands and return results. The syllabus specifies several types:</p>
            <ul class="list-disc ml-6">
                <li><strong>Arithmetic Operators</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>+</code>: Addition</li>
                        <li><code>-</code>: Subtraction</li>
                        <li><code>*</code>: Multiplication</li>
                        <li><code>/</code>: Division</li>
                        <li><code>%</code>: Modulus (remainder)</li>
                    </ul>
                    <p>Example: <code>int sum = 5 + 3;</code> results in <code>sum = 8</code></p>
                </li>
                <li><strong>Assignment Operators</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>=</code>: Simple assignment, e.g., <code>x = 10</code></li>
                        <li>Compound: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, e.g., <code>x += 5</code> is equivalent to <code>x = x + 5</code></li>
                    </ul>
                </li>
                <li><strong>Increment and Decrement Operators</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>++</code>: Increment by 1, e.g., <code>++x</code> (prefix) or <code>x++</code> (postfix)</li>
                        <li><code>--</code>: Decrement by 1, e.g., <code>--x</code> or <code>x--</code></li>
                    </ul>
                    <p>Prefix increments/decrements before use, postfix after use, e.g., <code>int x = 5; int y = ++x;</code> results in <code>x = 6, y = 6</code></p>
                </li>
                <li><strong>Comparison/Relational Operators</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>==</code>: Equal to</li>
                        <li><code>!=</code>: Not equal to</li>
                        <li><code>&gt;</code>: Greater than</li>
                        <li><code>&lt;</code>: Less than</li>
                        <li><code>&gt;=</code>: Greater than or equal to</li>
                        <li><code>&lt;=</code>: Less than or equal to</li>
                    </ul>
                    <p>Example: <code>5 &gt; 3</code> returns <code>true</code></p>
                </li>
                <li><strong>Logical Operators</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>&amp;&amp;</code>: Logical AND, true if both operands are true</li>
                        <li><code>||</code>: Logical OR, true if at least one operand is true</li>
                        <li><code>!</code>: Logical NOT, negates the operand</li>
                    </ul>
                    <p>Example: <code>(5 &gt; 3) &amp;&amp; (2 &lt; 4)</code> returns <code>true</code></p>
                </li>
                <li><strong>Bitwise Operators</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>&amp;</code>: Bitwise AND</li>
                        <li><code>|</code>: Bitwise OR</li>
                        <li><code>^</code>: Bitwise XOR</li>
                        <li><code>~</code>: Bitwise NOT</li>
                        <li><code>&lt;&lt;</code>: Left shift</li>
                        <li><code>&gt;&gt;</code>: Right shift</li>
                    </ul>
                    <p>Example: <code>12 &amp; 25</code> (in binary: 00001100 &amp; 00011001 = 00001000, result 8)</p>
                </li>
                <li><strong>Special Operators</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>.</code>: Member access, e.g., <code>obj.member</code></li>
                        <li><code>-&gt;</code>: Pointer member access, e.g., <code>ptr-&gt;member</code></li>
                        <li><code>[]</code>: Array subscript, e.g., <code>arr[0]</code></li>
                        <li><code>()</code>: Function call, e.g., <code>func()</code></li>
                        <li><code>new</code>, <code>delete</code>: Dynamic memory allocation, e.g., <code>int* ptr = new int; delete ptr;</code></li>
                        <li><code>sizeof</code>: Returns size of type or variable, e.g., <code>sizeof(int)</code> returns 4</li>
                        <li><code>?:</code>: Ternary conditional, e.g., <code>x &gt; 0 ? 1 : -1</code></li>
                        <li><code>,</code>: Comma operator, evaluates expressions sequentially, e.g., <code>a = 1, b = 2</code> (result is <code>b</code>)</li>
                    </ul>
                </li>
            </ul>
            <p>Operators are essential for performing computations, comparisons, and manipulations in C++ programs, with precedence and associativity defining evaluation order.</p>

            <h3 class="text-lg md:text-xl">7. Type Conversion</h3>
            <p>Type conversion, also known as type casting, is the process of converting one data type to another, crucial for handling different data types in expressions.</p>
            <ul class="list-disc ml-6">
                <li><strong>Implicit Type Conversion (Automatic)</strong>:
                    <ul class="list-circle ml-6">
                        <li>Performed by the compiler without programmer intervention.</li>
                        <li>Occurs when assigning a value of one type to a variable of another type or in expressions with mixed types.</li>
                        <li>Example: <code>int x = 10; float y = x;</code> (int to float, no data loss).</li>
                        <li>Rules: Converts from smaller to larger types without loss (e.g., <code>int</code> to <code>long</code>), but may lose data when converting larger to smaller (e.g., <code>long</code> to <code>int</code>).</li>
                    </ul>
                </li>
                <li><strong>Explicit Type Conversion (Manual or Type Casting)</strong>:
                    <ul class="list-circle ml-6">
                        <li>Performed manually using casting operators.</li>
                        <li>Syntax: <code>(type) expression</code>, e.g., <code>(int)3.14</code> converts float <code>3.14</code> to int <code>3</code>.</li>
                        <li>Used when implicit conversion is not performed or to ensure specific type, e.g., forcing a float to int for truncation.</li>
                        <li>Example: <code>float f = 3.14; int i = (int)f;</code> results in <code>i = 3</code>.</li>
                    </ul>
                </li>
            </ul>
            <p><strong>Data Loss Consideration</strong>: Explicit conversion can lead to data loss, especially when converting from floating-point to integer types, truncating decimal parts. Care must be taken to avoid unintended behavior.</p>

            <h3 class="text-lg md:text-xl">Summary Table of Key Concepts</h3>
            <div class="overflow-x-auto rounded-lg shadow-md">
                <table class="min-w-full bg-white">
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>Description</th>
                            <th>Examples</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Character Set</td>
                            <td>Collection of usable characters in C++ (letters, digits, symbols, etc.)</td>
                            <td>A-Z, 0-9, +, \n</td>
                        </tr>
                        <tr>
                            <td>Data Types</td>
                            <td>Define variable data type, size, and range</td>
                            <td>int, float, bool</td>
                        </tr>
                        <tr>
                            <td>Identifiers</td>
                            <td>Names for variables, functions, etc., following naming rules</td>
                            <td>myVar, _count, userName</td>
                        </tr>
                        <tr>
                            <td>Keywords</td>
                            <td>Reserved words with special meanings, cannot be identifiers</td>
                            <td>int, if, while</td>
                        </tr>
                        <tr>
                            <td>Variables</td>
                            <td>Named memory locations for data storage, declared and initialized</td>
                            <td>int age = 25;</td>
                        </tr>
                        <tr>
                            <td>Constants</td>
                            <td>Fixed values (numeric, character, string) that cannot change</td>
                            <td>const int MAX = 100; "Hello"</td>
                        </tr>
                        <tr>
                            <td>Operators</td>
                            <td>Symbols for operations (arithmetic, logical, etc.)</td>
                            <td>+, ==, &&, &lt;&lt;</td>
                        </tr>
                        <tr>
                            <td>Type Conversion</td>
                            <td>Converting one data type to another, implicit or explicit</td>
                            <td>(int)3.14, int to float</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section id="unit-2" class="section-card">
            <h2 class="text-xl md:text-2xl">Unit 2: Writing a Program in C++</h2>

            <h3 class="text-lg md:text-xl">Key Points</h3>
            <ul class="list-disc ml-6">
                <li>Variables in C++ must be declared with a type before use, and constants use <code>const</code>.</li>
                <li>Statements include input/output, assignments, and control flow like loops and conditionals.</li>
                <li>Simple C++ programs start with headers, use <code>main()</code>, and include I/O operations.</li>
                <li>The <code>iostream.h</code> header supports type-safe, device-independent input/output.</li>
                <li>Keyboard input uses <code>cin</code>, and screen output uses <code>cout</code>, with operators <code>&lt;&lt;</code> for output and <code>&gt;&gt;</code> for input.</li>
                <li>Cascading I/O operators allows chaining multiple operations, like <code>cout &lt;&lt; a &lt;&lt; b</code>.</li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Overview</h3>
            <p>C++ programming involves declaring variables, writing statements, and creating simple programs with input/output operations. The <code>iostream.h</code> header facilitates these operations, ensuring type safety and device independence. Keyboard and screen I/O use <code>cin</code> and <code>cout</code>, respectively, with operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> for output and input. Cascading these operators enhances efficiency by chaining multiple operations in one line.</p>

            <h3 class="text-lg md:text-xl">Declaration and Statements</h3>
            <p>Variables must be declared with a type (e.g., <code>int</code>, <code>double</code>) and can be initialized. Constants, declared with <code>const</code>, cannot be changed. Statements include input/output (e.g., <code>cout &lt;&lt; value;</code>), assignments (e.g., <code>x = x + 1;</code>), and control flow like <code>if</code> and <code>for</code> loops.</p>

            <h3 class="text-lg md:text-xl">Simple Programs and I/O</h3>
            <p>A simple C++ program includes headers like <code>&lt;iostream&gt;</code>, the <code>main()</code> function, and I/O operations. Keyboard input (<code>cin</code>) and screen output (<code>cout</code>) use operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>, respectively, supported by <code>iostream.h</code> for type-safe, device-independent operations.</p>

            <h3 class="text-lg md:text-xl">Cascading Operators</h3>
            <p>Cascading allows multiple <code>&lt;&lt;</code> or <code>&gt;&gt;</code> operations in one statement, like <code>cout &lt;&lt; "Hello" &lt;&lt; "World";</code>, improving readability and reducing code length.</p>

            <hr class="my-6 border-t border-gray-300">

            <h2 class="text-xl md:text-2xl">Survey Note: Detailed Exploration of Writing a Program in C++</h2>
            <p>This note provides an in-depth analysis of Unit-2: Writing a Program in C++, covering Declaration of Variables, Statements, Simple C++ Programs, Features of iostream.h, Keyboard and Screen I/O, Using I/O Operators (output operator <code>&lt;&lt;</code>, Input operator <code>&gt;&gt;</code>), and Cascading of I/O Operators. The content is structured to mimic a professional article, ensuring comprehensive coverage for learners and practitioners.</p>

            <h3 class="text-lg md:text-xl">1. Declaration of Variables</h3>
            <p>Variables are named storage locations that hold values of specific data types, essential for C++ programming. The declaration syntax includes:</p>
            <ul class="list-disc ml-6">
                <li>Single variable: <code>type identifier;</code>, e.g., <code>int option;</code>.</li>
                <li>Multiple variables: <code>type identifier-1, identifier-2, ..., identifier-n;</code>, e.g., <code>double sum, difference, product, quotient;</code>.</li>
                <li>Initialization: <code>type identifier = value;</code>, e.g., <code>int magicNumber = 88;</code>, or <code>type identifier-1 = value-1, ..., identifier-n = value-n;</code>, e.g., <code>double sum = 0.0, product = 1.0;</code>.</li>
            </ul>

            <h4>Rules and Guidelines:</h4>
            <ul class="list-disc ml-6">
                <li>Variables must be declared before use, and C++ is strongly typed, meaning a variable's type (e.g., <code>int</code> for integers like 123, not reals like 12.34) cannot change.</li>
                <li>Each variable can be declared once, and uninitialized variables contain garbage values, potentially leading to unexpected results if used without initialization.</li>
                <li>Declaration can occur anywhere in the program, but it's recommended just before first use, unlike older C standards requiring declarations at function start.</li>
                <li>Constants, declared with <code>const</code>, must be initialized at declaration and cannot be modified, e.g., <code>const double PI = 3.1415926;</code>. Naming convention for constants uses uppercase with underscores, like <code>MIN_VALUE</code>.</li>
            </ul>

            <h4>Fundamental Types:</h4>
            <p>C++ supports various data types, with typical sizes and ranges as shown in the table below:</p>
            <div class="overflow-x-auto rounded-lg shadow-md">
                <table class="min-w-full bg-white">
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Type</th>
                            <th>Description</th>
                            <th>Bytes (Typical)</th>
                            <th>Minimum (Typical)</th>
                            <th>Maximum (Typical)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Integers</td>
                            <td><code>int</code> (or <code>signed int</code>)</td>
                            <td>Signed integer (at least 16 bits)</td>
                            <td>4 (2)</td>
                            <td>-2147483648</td>
                            <td>2147483647</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>unsigned int</code></td>
                            <td>Unsigned integer (at least 16 bits)</td>
                            <td>4 (2)</td>
                            <td>0</td>
                            <td>4294967295</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>char</code></td>
                            <td>Character (signed or unsigned, implementation-dependent)</td>
                            <td>1</td>
                            <td>-128 (if signed)</td>
                            <td>127 (if signed)</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>signed char</code></td>
                            <td>Signed tiny integer</td>
                            <td>1</td>
                            <td>-128</td>
                            <td>127</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>unsigned char</code></td>
                            <td>Unsigned tiny integer</td>
                            <td>1</td>
                            <td>0</td>
                            <td>255</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>short</code> (or <code>signed short</code>)</td>
                            <td>Short signed integer (at least 16 bits)</td>
                            <td>2</td>
                            <td>-32768</td>
                            <td>32767</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>unsigned short</code></td>
                            <td>Unsigned short integer (at least 16 bits)</td>
                            <td>2</td>
                            <td>0</td>
                            <td>65535</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>long</code> (or <code>signed long</code>)</td>
                            <td>Long signed integer (at least 32 bits)</td>
                            <td>4 (8)</td>
                            <td>-2147483648</td>
                            <td>2147483647</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>unsigned long</code></td>
                            <td>Unsigned long integer (at least 32 bits)</td>
                            <td>4 (8)</td>
                            <td>0</td>
                            <td>Same as above</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>long long</code> (C++11)</td>
                            <td>Very long signed integer (at least 64 bits)</td>
                            <td>8</td>
                            <td>-2^63</td>
                            <td>2^63-1</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>unsigned long long</code> (C++11)</td>
                            <td>Unsigned very long integer (at least 64 bits)</td>
                            <td>8</td>
                            <td>0</td>
                            <td>2^64-1</td>
                        </tr>
                        <tr>
                            <td>Real Numbers</td>
                            <td><code>float</code></td>
                            <td>Floating-point, ≈7 digits (IEEE 754 single-precision)</td>
                            <td>4</td>
                            <td>±1.40239846×10^-45</td>
                            <td>±3.40282347×10^38</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>double</code></td>
                            <td>Double precision, ≈15 digits (IEEE 754 double-precision)</td>
                            <td>8</td>
                            <td>±4.94065645841246544×10^-324</td>
                            <td>±1.79769313486231570×10^308</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>long double</code></td>
                            <td>Long double precision, ≈19 digits</td>
                            <td>12 (8)</td>
                            <td>-</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td>Boolean Numbers</td>
                            <td><code>bool</code></td>
                            <td>Boolean value (<code>true</code> or <code>false</code>)</td>
                            <td>1</td>
                            <td><code>false</code> (0)</td>
                            <td><code>true</code> (1 or non-zero)</td>
                        </tr>
                        <tr>
                            <td>Wide Characters</td>
                            <td><code>wchar_t</code>, <code>char16_t</code> (C++11), <code>char32_t</code> (C++11)</td>
                            <td>Wide (double-byte) character</td>
                            <td>2 (4)</td>
                            <td>-</td>
                            <td>-</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h4>Identifiers:</h4>
            <ul class="list-disc ml-6">
                <li>Must start with a letter or underscore, can include letters, digits, and underscores, up to 255 characters (compiler-dependent).</li>
                <li>Cannot be keywords (e.g., <code>int</code>, <code>double</code>, <code>if</code>) and are case-sensitive (e.g., <code>rose</code> ≠ <code>Rose</code>).</li>
                <li>Naming convention: Camel-case, e.g., <code>theFontSize</code>, <code>roomNumber</code>.</li>
            </ul>

            <h3 class="text-lg md:text-xl">2. Statements</h3>
            <p>Statements are the building blocks of C++ programs, executed sequentially. They include:</p>
            <ul class="list-disc ml-6">
                <li><strong>Input/Output Statements</strong>: Use <code>cin</code> for input (e.g., <code>cin &gt;&gt; variable;</code>) and <code>cout</code> for output (e.g., <code>cout &lt;&lt; value;</code>), requiring the <code>&lt;iostream&gt;</code> header.</li>
                <li><strong>Assignment Statements</strong>: Assign values, e.g., <code>x = x + 1;</code>, where the left-hand side must be a variable (unlike mathematical equations like <code>x + y = 1</code>, which are invalid in programming).</li>
                <li><strong>Control Flow Statements</strong>: Include conditionals (<code>if</code>, <code>else</code>, <code>switch</code>), loops (<code>for</code>, <code>while</code>, <code>do-while</code>), e.g., <code>for (int i = 0; i &lt; size; ++i)</code>.</li>
                <li><strong>Function Calls</strong>: Invoke functions, e.g., <code>area1 = getArea(radius1);</code>.</li>
                <li><strong>Return Statements</strong>: Exit functions, e.g., <code>return 0;</code>.</li>
            </ul>
            <p>All statements end with a semicolon (<code>;</code>), and compound statements use braces <code>{ }</code>.</p>

            <h3 class="text-lg md:text-xl">3. Simple C++ Programs</h3>
            <p>A simple C++ program follows a standard structure:</p>
            <ul class="list-disc ml-6">
                <li><strong>Headers</strong>: Include necessary libraries, e.g., <code>#include &lt;iostream&gt;</code> for I/O.</li>
                <li><strong>Namespace</strong>: Often use <code>using namespace std;</code> to avoid prefixing with <code>std::</code>.</li>
                <li><strong>main() Function</strong>: The entry point, e.g.,
<pre><code class="language-cpp">int main() {
    int a, b;
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; "Sum: " &lt;&lt; a + b;
    return 0;
}</code></pre>
                </li>
                <li><strong>Components</strong>: Include variable declarations, I/O operations, and logic (e.g., calculations, loops).</li>
            </ul>
            <p>These programs demonstrate basic programming concepts, starting with simple input/output and progressing to more complex logic.</p>

            <h3 class="text-lg md:text-xl">4. Features of iostream.h</h3>
            <p>The <code>iostream.h</code> header (modern C++ uses <code>&lt;iostream&gt;</code>) is crucial for I/O operations, offering:</p>
            <ul class="list-disc ml-6">
                <li><strong>Type Safety</strong>: Operations are defined for each data type, with compiler errors for undefined operations.</li>
                <li><strong>Device Independence</strong>: Same operations work across devices like keyboard, file, or network.</li>
                <li><strong>Stream Classes</strong>: Includes <code>istream</code> for input, <code>ostream</code> for output, and <code>iostream</code> for bidirectional operations.</li>
                <li><strong>Standard Stream Objects</strong>: <code>cin</code> (keyboard input, <code>istream</code>), <code>cout</code> (screen output, <code>ostream</code>), <code>cerr</code> (error stream, unbuffered), <code>clog</code> (log stream, buffered).</li>
            </ul>
            <p>This ensures robust and flexible I/O handling in C++ programs.</p>

            <h3 class="text-lg md:text-xl">5. Keyboard and Screen I/O</h3>
            <ul class="list-disc ml-6">
                <li><strong>Keyboard Input</strong>: Uses <code>cin</code>, an object of <code>istream</code>, connected to the keyboard by default. Example: <code>cin &gt;&gt; variable;</code>.</li>
                <li><strong>Screen Output</strong>: Uses <code>cout</code>, an object of <code>ostream</code>, connected to the display console. Example: <code>cout &lt;&lt; value;</code>.</li>
                <li><strong>Capabilities</strong>: Supports formatted I/O via <code>&lt;&lt;</code> and <code>&gt;&gt;</code>, and unformatted I/O via functions like <code>put()</code> and <code>get()</code>.</li>
            </ul>
            <p>This facilitates interaction with users, essential for program functionality.</p>

            <h3 class="text-lg md:text-xl">6. Using I/O Operators</h3>
            <p>These operators are fundamental for I/O, with extensive support for various data types.</p>

            <h3 class="text-lg md:text-xl">7. Cascading of I/O Operators</h3>
            <p>Cascading involves consecutive use of <code>&lt;&lt;</code> or <code>&gt;&gt;</code> in a single statement, possible because these operators return references to their respective streams:</p>
            <ul class="list-disc ml-6">
                <li><strong>Definition</strong>: Multiple uses, e.g., <code>cout &lt;&lt; "Hello" &lt;&lt; " " &lt;&lt; "World";</code> or <code>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</code>.</li>
                <li><strong>Benefits</strong>: Enhances readability, reduces code size, and allows continuous operations.</li>
                <li><strong>Implementation</strong>: For non-primitive data types, operators must be overloaded using friend functions, as seen in examples with linked lists.</li>
                <li><strong>Example Program</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main() {
    int a, b;
    cin &gt;&gt; a &gt;&gt; b; // Cascading input
    cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b; // Cascading output
    return 0;
}</code></pre>
                </li>
            </ul>
            <p>This feature is crucial for efficient I/O handling in C++.</p>

            <h4>Summary</h4>
            <p>This note covers all aspects of writing C++ programs as per the syllabus, from variable declaration and statements to I/O operations and cascading. It provides examples, tables for clarity, and detailed explanations for comprehensive understanding.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Key Citations</h3>
            <ul class="list-disc ml-6">
                <li><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_IO.html" target="_blank" class="text-blue-600 hover:underline">C++ IO Streams and File Input/Output detailed guide</a></li>
                <li><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp1_basics.html" target="_blank" class="text-blue-600 hover:underline">C++ Basics comprehensive programming tutorial</a></li>
                <li><a href="https://www.geeksforgeeks.org/cascading-of-input-output-operators-in-c/" target="_blank" class="text-blue-600 hover:underline">Cascading of Input/Output Operators in C++ explained</a></li>
                <li><a href="https://ecomputernotes.com/cpp/introduction-to-oop/input-output-statements" target="_blank" class="text-blue-600 hover:underline">Input Output Statements in C++ detailed notes</a></li>
            </ul>
        </section>

        <section id="unit-3" class="section-card">
            <h2 class="text-xl md:text-2xl">Unit 3: Control Statements/Flow of Control in C++</h2>

            <p>Control statements in C++ are used to direct the flow of execution in a program, enabling decision-making, repetition, and changes to the normal sequence of operations. They are fundamental to creating dynamic and efficient programs. This note covers:</p>
            <ul class="list-disc ml-6">
                <li><strong>Conditional Statements</strong>: <code>if</code>, <code>if-else</code>, <code>switch-case</code></li>
                <li><strong>Loop Statements</strong>: <code>for</code>, <code>while</code>, <code>do-while</code>, nested loops</li>
                <li><strong>Jump Statements</strong>: <code>break</code>, <code>continue</code>, <code>goto</code>, <code>exit()</code></li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">1. Conditional Statements</h3>
            <p>Conditional statements allow the program to execute specific blocks of code based on whether a condition evaluates to true or false. They are key to decision-making in C++.</p>

            <h4>if Statement</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: Executes a block of code if a specified condition is true.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">if (condition) {
    // code to execute if condition is true
}</code></pre>
                </li>
                <li><strong>Explanation</strong>: The condition (an expression that evaluates to true or false) is checked. If true (non-zero), the code inside the block runs; if false (zero), it is skipped.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    int a = 10;
    if (a &gt; 5) {
        std::cout &lt;&lt; "a is greater than 5\n";
    }
    return 0;
}</code></pre>
                    <p><strong>Output</strong>: <code>a is greater than 5</code></p>
                </li>
            </ul>

            <h4>if-else Statement</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: Provides an alternative block of code to execute when the condition is false.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">if (condition) {
    // code if condition is true
} else {
    // code if condition is false
}</code></pre>
                </li>
                <li><strong>Explanation</strong>: If the condition is true, the <code>if</code> block executes; otherwise, the <code>else</code> block executes.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    int a = 3;
    if (a &gt; 5) {
        std::cout &lt;&lt; "a is greater than 5\n";
    } else {
        std::cout &lt;&lt; "a is less than or equal to 5\n";
    }
    return 0;
}</code></pre>
                    <p><strong>Output</strong>: <code>a is less than or equal to 5</code></p>
                </li>
            </ul>

            <h4>switch-case Statement</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: Selects one of many code blocks to execute based on the value of an expression.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">switch (expression) {
    case value1:
        // code for value1
        break;
    case value2:
        // code for value2
        break;
    default:
        // code if no case matches
}</code></pre>
                </li>
                <li><strong>Explanation</strong>: The expression is evaluated, and execution jumps to the matching <code>case</code>. The <code>break</code> statement prevents fall-through to subsequent cases, and <code>default</code> handles unmatched values.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    int day = 3;
    switch (day) {
        case 1:
            std::cout &lt;&lt; "Monday\n";
            break;
        case 2:
            std::cout &lt;&lt; "Tuesday\n";
            break;
        case 3:
            std::cout &lt;&lt; "Wednesday\n";
            break;
        default:
            std::cout &lt;&lt; "Invalid day\n";
    }
    return 0;
}</code></pre>
                    <p><strong>Output</strong>: <code>Wednesday</code></p>
                </li>
            </ul>
            <p><strong>C++ Note</strong>: <code>switch</code> in C++ supports integers, characters, and enumerations. C++17 also introduced the <code>[[fallthrough]]</code> attribute to explicitly allow case fall-through when intended.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">2. Loop Statements</h3>
            <p>Loop statements enable repeated execution of a code block, either for a set number of times or while a condition remains true. They are essential for tasks like iteration and repetition.</p>

            <h4>for Loop</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: Executes a block of code a specific number of times.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">for (initialization; condition; increment) {
    // code to repeat
}</code></pre>
                </li>
                <li><strong>Explanation</strong>: The <code>initialization</code> sets up a loop variable, the <code>condition</code> is checked before each iteration (if true, the block runs), and the <code>increment</code> updates the variable after each iteration.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    for (int i = 0; i &lt; 5; i++) {
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    return 0;
}</code></pre>
                    <p><strong>Output</strong>: <code>0 1 2 3 4</code></p>
                </li>
            </ul>

            <h4>while Loop</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: Repeats a block of code as long as a condition is true, checking the condition before each iteration.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">while (condition) {
    // code to repeat
}</code></pre>
                </li>
                <li><strong>Explanation</strong>: The condition is evaluated before the loop body executes. If true, the block runs; if false, the loop ends.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    int i = 0;
    while (i &lt; 5) {
        std::cout &lt;&lt; i &lt;&lt; " ";
        i++;
    }
    return 0;
}</code></pre>
                    <p><strong>Output</strong>: <code>0 1 2 3 4</code></p>
                </li>
            </ul>

            <h4>do-while Loop</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: Similar to <code>while</code>, but the condition is checked after the block executes, ensuring at least one execution.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">do {
    // code to repeat
} while (condition);</code></pre>
                </li>
                <li><strong>Explanation</strong>: The code block runs first, then the condition is checked. If true, the loop repeats; if false, it stops.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    int i = 0;
    do {
        std::cout &lt;&lt; i &lt;&lt; " ";
        i++;
    } while (i &lt; 5);
    return 0;
}</code></pre>
                    <p><strong>Output</strong>: <code>0 1 2 3 4</code></p>
                </li>
            </ul>

            <h4>Nested Loops</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: A loop inside another loop, used for complex iterations like processing multi-dimensional data.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    for (int i = 0; i &lt; 2; i++) {
        for (int j = 0; j &lt; 2; j++) {
            std::cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; ", j=" &lt;&lt; j &lt;&lt; "\n";
        }
    }
    return 0;
}</code></pre>
                    <p><strong>Output</strong>:</p>
<pre><code>i=0, j=0
i=0, j=1
i=1, j=0
i=1, j=1</code></pre>
                </li>
            </ul>
            <p><strong>C++ Note</strong>: C++11 introduced the range-based <code>for</code> loop for easier iteration over arrays or containers:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    int arr[] = {1, 2, 3};
    for (int num : arr) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    return 0;
}</code></pre>
            <p><strong>Output</strong>: <code>1 2 3</code></p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">3. Jump Statements</h3>
            <p>Jump statements alter the normal flow of execution, allowing you to exit loops, skip iterations, or terminate the program.</p>

            <h4>break Statement</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: Exits a loop or <code>switch</code> statement immediately.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">break;</code></pre>
                </li>
                <li><strong>Explanation</strong>: When encountered, it terminates the innermost loop or <code>switch</code>, moving control to the next statement outside.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    for (int i = 0; i &lt; 10; i++) {
        if (i == 5) {
            break;
        }
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    return 0;
}</code></pre>
                    <p><strong>Output</strong>: <code>0 1 2 3 4</code></p>
                </li>
            </ul>

            <h4>continue Statement</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: Skips the rest of the current loop iteration and moves to the next iteration.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">continue;</code></pre>
                </li>
                <li><strong>Explanation</strong>: It bypasses the remaining code in the current iteration and updates the loop counter for the next iteration.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    for (int i = 0; i &lt; 10; i++) {
        if (i % 2 == 0) {
            continue;
        }
        std::cout &lt;&lt; i &lt;&lt; " ";
    }
    return 0;
}</code></pre>
                    <p><strong>Output</strong>: <code>1 3 5 7 9</code></p>
                </li>
            </ul>

            <h4>goto Statement</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: Transfers control to a labeled statement in the program (use sparingly due to readability issues).</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">goto label;
// ...
label:
    // code</code></pre>
                </li>
                <li><strong>Explanation</strong>: Jumps to the labeled statement, bypassing normal flow. It’s discouraged in modern C++ programming.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    int i = 0;
    loop:
        std::cout &lt;&lt; i &lt;&lt; " ";
        i++;
        if (i &lt; 5) {
            goto loop;
        }
    return 0;
}</code></pre>
                    <p><strong>Output</strong>: <code>0 1 2 3 4</code></p>
                </li>
            </ul>

            <h4>exit() Function</h4>
            <ul class="list-disc ml-6">
                <li><strong>Purpose</strong>: Terminates the program immediately, returning a status code to the operating system.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">#include &lt;cstdlib&gt;
std::exit(status);</code></pre>
                </li>
                <li><strong>Explanation</strong>: Stops the program execution, useful for error handling or forced termination. Status <code>0</code> typically indicates success.</li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
int main() {
    std::cout &lt;&lt; "Starting...\n";
    std::exit(0);
    std::cout &lt;&lt; "This won't print\n";
    return 0;
}</code></pre>
                    <p><strong>Output</strong>: <code>Starting...</code></p>
                </li>
            </ul>
            <p><strong>C++ Note</strong>: C++ offers exception handling (<code>try</code>, <code>catch</code>, <code>throw</code>) as a more structured alternative to <code>exit()</code> or <code>goto</code> for managing errors:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main() {
    try {
        throw "Error!";
    } catch (const char* msg) {
        std::cerr &lt;&lt; msg &lt;&lt; "\n";
    }
    return 0;
}</code></pre>
            <p><strong>Output</strong>: <code>Error!</code></p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Summary Table</h3>
            <div class="overflow-x-auto rounded-lg shadow-md">
                <table class="min-w-full bg-white">
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Types</th>
                            <th>Purpose</th>
                            <th>Example Output</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Conditional</td>
                            <td>if, if-else, switch-case</td>
                            <td>Decision-making based on conditions</td>
                            <td><code>Wednesday</code></td>
                        </tr>
                        <tr>
                            <td>Loop</td>
                            <td>for, while, do-while</td>
                            <td>Repeated execution of code</td>
                            <td><code>0 1 2 3 4</code></td>
                        </tr>
                        <tr>
                            <td>Jump</td>
                            <td>break, continue, goto, exit</td>
                            <td>Alter flow or terminate execution</td>
                            <td><code>0 1 2 3 4</code> (break)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Conclusion</h3>
            <p>Control statements in C++—conditional statements (<code>if</code>, <code>if-else</code>, <code>switch-case</code>), loop statements (<code>for</code>, <code>while</code>, <code>do-while</code>, nested loops), and jump statements (<code>break</code>, <code>continue</code>, <code>goto</code>, <code>exit()</code>)—are essential for controlling program flow. C++ enhances these with features like range-based <code>for</code> loops and exception handling, providing flexibility and power for writing efficient, structured code. Mastering these constructs is key to developing robust C++ programs.</p>
        </section>

        <section id="unit-4" class="section-card">
            <h2 class="text-xl md:text-2xl">Unit 4: Functions and Program Structures in C++</h2>

            <h3 class="text-lg md:text-xl">Key Points</h3>
            <ul class="list-disc ml-6">
                <li>Functions in C++ are blocks of code that perform specific tasks, with clear definitions and return statements.</li>
                <li>Functions can be classified by parameters and return values, and include user-defined and library types.</li>
                <li>Parameters are divided into formal (defined in the function) and actual (passed during calls), with local and global variables affecting scope.</li>
                <li>Default arguments allow flexibility in function calls, while multi-function programs use multiple interconnected functions.</li>
                <li>Recursive functions call themselves, requiring a base case to avoid infinite loops, and use stack memory, risking overflow.</li>
                <li>Preprocessor directives like <code>#include</code> and <code>#define</code> manage code, and header files like <code>&lt;iostream&gt;</code> provide standard library access.</li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Defining Functions</h3>
            <p>Functions are essential in C++, allowing code reuse and modularity. They are defined with a return type, name, and optional parameters, executed when called.</p>

            <h3 class="text-lg md:text-xl">Return Statements</h3>
            <p>The <code>return</code> statement exits a function, optionally returning a value matching the declared type, crucial for function output.</p>

            <h3 class="text-lg md:text-xl">Function Types and Access</h3>
            <p>Functions vary by parameters and return values, with user-defined and library functions. Parameters are formal (in definition) or actual (in calls), affecting how functions interact with variables.</p>

            <h3 class="text-lg md:text-xl">Variable Scope and Defaults</h3>
            <p>Local variables are function-specific, while global variables are program-wide. Default arguments provide optional parameter values, enhancing flexibility.</p>

            <h3 class="text-lg md:text-xl">Program Structure</h3>
            <p>Multi-function programs involve multiple functions, while recursive functions solve problems by self-calling, needing a base case. Both use stack memory, with recursion risking overflow.</p>

            <h3 class="text-lg md:text-xl">Preprocessors and Headers</h3>
            <p>Preprocessor directives like <code>#include</code> and <code>#define</code> prepare code, and header files like <code>&lt;iostream&gt;</code> and <code>&lt;cmath&gt;</code> offer standard library functions, essential for I/O and math operations.</p>

            <hr class="my-6 border-t border-gray-300">

            <h2 class="text-xl md:text-2xl">Detailed Note on Functions and Program Structures in C++</h2>
            <p>This comprehensive note covers the syllabus for <strong>Unit-4: Functions and Program Structures</strong> in C++, detailing each topic with examples and explanations to ensure a thorough understanding. It is designed for learners at an an introductory level, providing a foundation for writing modular and efficient C++ programs.</p>

            <h3 class="text-lg md:text-xl">1. Defining a Function</h3>
            <p>A function in C++ is a reusable block of code that performs a specific task, enhancing code modularity and readability. It is defined using the following syntax:</p>
<pre><code class="language-cpp">return_type function_name(parameters) {
    // function body
}</code></pre>
            <ul class="list-disc ml-6">
                <li><strong>return_type</strong>: Specifies the data type of the value returned by the function (e.g., <code>int</code>, <code>float</code>, <code>void</code> for no return value).</li>
                <li><strong>function_name</strong>: The identifier for the function, following naming conventions.</li>
                <li><strong>parameters</strong>: Optional; these are variables that receive values when the function is called, enclosed in parentheses.</li>
            </ul>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">int add(int a, int b) {
    return a + b;
}</code></pre>
            <p>Here, <code>add</code> is the function name, <code>int</code> is the return type, and <code>a</code> and <code>b</code> are parameters. The function adds two numbers and returns the result.</p>
            <p>Functions must be defined before use or declared with a prototype to ensure the compiler recognizes them during calls.</p>

            <h3 class="text-lg md:text-xl">2. Return Statement</h3>
            <p>The return statement is used to exit a function and optionally return a value to the calling function. Its syntax is:</p>
<pre><code class="language-cpp">return expression;</code></pre>
            <ul class="list-disc ml-6">
                <li>The <code>expression</code> can be a variable, constant, or computation, and its type must match the function's return type.</li>
                <li>For functions with return type <code>void</code>, the return statement can be <code>return;</code> without an expression, simply exiting the function.</li>
            </ul>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">int getTen() {
    int res = 10;
    return res; // Returns the value 10
}</code></pre>
            <p>This function returns 10, which can be used by the calling code. The return statement is crucial for functions that compute and pass back results.</p>

            <h3 class="text-lg md:text-xl">3. Types of Functions</h3>
            <p>Functions in C++ can be classified based on their parameters and return values, providing flexibility in design:</p>
            <ul class="list-disc ml-6">
                <li><strong>No arguments, no return value</strong>:
                    <ul class="list-circle ml-6">
                        <li>Example: <code>void printHello() { cout &lt;&lt; "Hello"; }</code> – Prints "Hello" without taking inputs or returning values.</li>
                    </ul>
                </li>
                <li><strong>No arguments, with return value</strong>:
                    <ul class="list-circle ml-6">
                        <li>Example: <code>int getNumber() { return 5; }</code> – Returns a fixed value without parameters.</li>
                    </ul>
                </li>
                <li><strong>With arguments, no return value</strong>:
                    <ul class="list-circle ml-6">
                        <li>Example: <code>void printSum(int a, int b) { cout &lt;&lt; a + b; }</code> – Takes inputs but does not return a value, printing the sum.</li>
                    </ul>
                </li>
                <li><strong>With arguments, with return value</strong>:
                    <ul class="list-circle ml-6">
                        <li>Example: <code>int add(int a, int b) { return a + b; }</code> – Takes inputs and returns their sum.</li>
                    </ul>
                </li>
            </ul>
            <p>Additionally, functions are categorized as:</p>
            <ul class="list-disc ml-6">
                <li><strong>User-defined functions</strong>: Created by the programmer for specific tasks.</li>
                <li><strong>Library functions</strong>: Provided by the C++ standard library, such as <code>max()</code> from <code>&lt;algorithm&gt;</code>.</li>
            </ul>
            <p>This classification helps in understanding function usage in different contexts, from simple output to complex computations.</p>

            <h3 class="text-lg md:text-xl">4. Accessing a Function: Actual and Formal Parameters/Arguments</h3>
            <p>Functions interact with data through parameters, divided into:</p>
            <ul class="list-disc ml-6">
                <li><strong>Formal parameters</strong>: Variables declared in the function definition, acting as placeholders for values passed during calls.</li>
                <li><strong>Actual parameters</strong>: The actual values or expressions passed to the function when it is called.</li>
            </ul>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">void printNum(int n) { // n is a formal parameter
    cout &lt;&lt; n;
}

int main() {
    int num = 5;
    printNum(num); // num is an actual parameter
    return 0;
}</code></pre>
            <p>Here, <code>n</code> is the formal parameter in <code>printNum</code>, and <code>num</code> is the actual parameter passed from <code>main()</code>. The number and type of actual parameters must match the formal parameters for successful execution.</p>
            <p>This distinction is crucial for understanding how functions receive and process data, ensuring correct parameter passing.</p>

            <h3 class="text-lg md:text-xl">5. Local and Global Variables</h3>
            <p>Variables in C++ have scopes that determine their accessibility:</p>
            <ul class="list-disc ml-6">
                <li><strong>Local variables</strong>:
                    <ul class="list-circle ml-6">
                        <li>Declared inside a function or block, accessible only within that scope.</li>
                        <li>Example: <code>int localVar = 5;</code> inside <code>main()</code> is local to <code>main()</code> and cannot be accessed outside it.</li>
                    </ul>
                </li>
                <li><strong>Global variables</strong>:
                    <ul class="list-circle ml-6">
                        <li>Declared outside all functions, accessible from any part of the program.</li>
                        <li>Example: <code>int globalVar = 10;</code> can be used in any function, enhancing program-wide data sharing.</li>
                    </ul>
                </li>
            </ul>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int globalVar = 10; // Global variable

int main() {
    int localVar = 5; // Local variable
    cout &lt;&lt; "Global: " &lt;&lt; globalVar &lt;&lt; ", Local: " &lt;&lt; localVar;
    return 0;
}</code></pre>
            <p>Global variables are automatically initialized (e.g., 0 for integers), while local variables must be explicitly initialized to avoid undefined behavior.</p>
            <p>This scope distinction is vital for managing variable visibility and avoiding naming conflicts.</p>

            <h3 class="text-lg md:text-xl">6. Default Arguments</h3>
            <p>Default arguments allow a function to be called without specifying all parameters, using predefined values for missing arguments.</p>
            <p><strong>Syntax</strong>:</p>
<pre><code class="language-cpp">return_type function_name(type param1 = value1, type param2 = value2) {
    // function body
}</code></pre>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">int getSum(int x, int y = 20) {
    return x + y;
}

int main() {
    cout &lt;&lt; getSum(5); // Uses y = 20 by default, output: 25
    cout &lt;&lt; getSum(5, 10); // Overrides default with y = 10, output: 15
    return 0;
}</code></pre>
            <p>Default arguments must be assigned from right to left, ensuring the function can handle calls with fewer arguments, enhancing flexibility.</p>

            <h3 class="text-lg md:text-xl">7. Multi-function Program</h3>
            <p>A multi-function program is one that contains multiple functions, each performing specific tasks, and they can call each other, including the <code>main()</code> function.</p>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void printHello() {
    cout &lt;&lt; "Hello";
}

int main() {
    printHello(); // Calls the printHello() function
    return 0;
}</code></pre>
            <p>Functions can be defined in the same file or across multiple files, linked using function declarations, promoting modularity and code organization.</p>
            <p>This structure is common in larger programs, allowing division of labor among functions.</p>

            <h3 class="text-lg md:text-xl">8. Recursive Function</h3>
            <p>A recursive function is a function that calls itself to solve a smaller instance of the same problem, requiring:</p>
            <ul class="list-disc ml-6">
                <li><strong>Base case</strong>: A condition where the function stops calling itself to prevent infinite recursion.</li>
                <li><strong>Recursive case</strong>: Where the function calls itself with modified arguments.</li>
            </ul>
            <p><strong>Example: Factorial Calculation</strong></p>
<pre><code class="language-cpp">int factorial(int n) {
    if (n == 0) // Base case
        return 1;
    else // Recursive case
        return n * factorial(n - 1);
}</code></pre>
            <ul class="list-disc ml-6">
                <li><strong>How it works</strong>: Each call creates a new stack frame in memory, storing data until the base case is reached. The function then returns, combining results, and stack frames are destroyed.</li>
                <li><strong>Memory usage</strong>: Uses stack memory, which can lead to <strong>stack overflow</strong> if too many recursive calls occur, especially with infinite recursion.</li>
                <li><strong>Applications</strong>: Useful for problems like factorial, Fibonacci, Tower of Hanoi, tree/graph traversal, and dynamic programming.</li>
                <li><strong>Drawbacks</strong>: High memory usage, potential for stack overflow, code complexity, and debugging challenges.</li>
            </ul>
            <p>This technique is powerful for solving problems with recursive structures, but care must be taken to ensure termination.</p>

            <h3 class="text-lg md:text-xl">9. Common C++ Preprocessor Directives</h3>
            <p>Preprocessor directives are commands processed before compilation, preparing the code for the compiler. Common directives include:</p>
            <ul class="list-disc ml-6">
                <li><strong><code>#include</code></strong>: Includes header files, e.g., <code>#include &lt;iostream&gt;</code> for I/O operations.</li>
                <li><strong><code>#define</code></strong>: Defines constants or macros, e.g., <code>#define PI 3.14159</code> for a constant value.</li>
                <li><strong><code>#ifdef</code>, <code>#ifndef</code>, <code>#endif</code></strong>: Used for conditional compilation, e.g., <code>#ifdef DEBUG</code> for debug-specific code.</li>
                <li><strong><code>#if</code>, <code>#else</code>, <code>#elif</code></strong>: For more complex conditional compilation based on expressions.</li>
            </ul>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">#define PI 3.14159
#include &lt;iostream&gt;</code></pre>
            <p>These directives enhance code management, portability, and conditional execution, crucial for large projects.</p>

            <h3 class="text-lg md:text-xl">10. Header Files</h3>
            <p>Header files contain declarations of functions, classes, and variables, included using <code>#include</code>. The syllabus lists several, with their purposes:</p>
            <div class="overflow-x-auto rounded-lg shadow-md">
                <table class="min-w-full bg-white">
                    <thead>
                        <tr>
                            <th>Header File</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>stdio.h</code></td>
                            <td>Standard input/output (C-style, less common in C++; use <code>&lt;iostream&gt;</code>).</td>
                        </tr>
                        <tr>
                            <td><code>iostream.h</code></td>
                            <td>Input/output streams (C++ style, outdated; use <code>&lt;iostream&gt;</code>).</td>
                        </tr>
                        <tr>
                            <td><code>ctype.h</code></td>
                            <td>Character handling functions (e.g., <code>isalpha()</code>, <code>toupper()</code>).</td>
                        </tr>
                        <tr>
                            <td><code>strings.h</code></td>
                            <td>String manipulation (C-style; use <code>&lt;string&gt;</code> for C++ strings).</td>
                        </tr>
                        <tr>
                            <td><code>maths.h</code></td>
                            <td>Mathematical functions (likely a typo for <code>math.h</code>; use <code>&lt;cmath&gt;</code>).</td>
                        </tr>
                        <tr>
                            <td><code>stdlib.h</code></td>
                            <td>General utilities (e.g., memory allocation; use <code>&lt;cstdlib&gt;</code> for C++).</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p><strong>Note</strong>: In modern C++, prefer C++-style headers (e.g., <code>&lt;iostream&gt;</code>, <code>&lt;cmath&gt;</code>, <code>&lt;cstdlib&gt;</code>) over C-style headers (e.g., <code>stdio.h</code>, <code>math.h</code>) for better compatibility and features.</p>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt; // Preferred over iostream.h
#include &lt;cmath&gt;    // Preferred over maths.h</code></pre>
            <p>Header files are essential for accessing standard library functionality, ensuring programs can perform I/O, math operations, and more.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Conclusion</h3>
            <p>This unit provides a foundation for understanding functions and program structures in C++, covering definition, usage, and management. It equips learners with the tools to write modular, efficient, and maintainable code, leveraging functions, variables, and standard library resources effectively.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Key Citations</h3>
            <ul class="list-disc ml-6">
                <li><a href="https://www.geeksforgeeks.org/functions-in-cpp/" target="_blank" class="text-blue-600 hover:underline">Functions in C++ GeeksforGeeks</a></li>
                <li><a href="https://www.geeksforgeeks.org/cpp-recursion/" target="_blank" class="text-blue-600 hover:underline">C++ Recursion GeeksforGeeks</a></li>
                <li><a href="https://www.tutorialspoint.com/cplusplus/cpp_quick_guide.htm" target="_blank" class="text-blue-600 hover:underline">C++ Quick Guide TutorialsPoint</a></li>
            </ul>
        </section>

        <section id="unit-5" class="section-card">
            <h2 class="text-xl md:text-2xl">Unit 5: Arrays in C++ Programming</h2>

            <h3 class="text-lg md:text-xl">Introduction to Arrays</h3>
            <p>An array is a collection of elements of the same data type stored in contiguous memory locations. Arrays allow efficient storage and manipulation of multiple values under a single variable name, accessed using indices. They are widely used for tasks like storing lists, matrices, or datasets.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">1. Array Notation</h3>
            <ul class="list-disc ml-6">
                <li><strong>Definition</strong>: Arrays are denoted by a variable name followed by an index in square brackets <code>[ ]</code>. The index specifies the position of an element in the array, starting from 0.</li>
                <li><strong>Syntax</strong>: <code>data_type array_name[size];</code></li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">int numbers[5]; // Declares an array of 5 integers
numbers[0] = 10; // First element
numbers[4] = 50; // Last element</code></pre>
                </li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">2. Array Declaration</h3>
            <ul class="list-disc ml-6">
                <li><strong>Definition</strong>: Declaring an array involves specifying its data type, name, and size. The size must be a constant integer expression at compile time.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">data_type array_name[size];</code></pre>
                </li>
                <li><strong>Rules</strong>:
                    <ul class="list-circle ml-6">
                        <li>The size must be non-negative.</li>
                        <li>Arrays cannot be resized after declaration.</li>
                        <li>Elements are accessed using indices from <code>0</code> to <code>size-1</code>.</li>
                    </ul>
                </li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[3]; // Declaration of an array of 3 integers
    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;
    cout &lt;&lt; "First element: " &lt;&lt; arr[0] &lt;&lt; endl; // Output: 1
    return 0;
}</code></pre>
                </li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">3. Array Initialization</h3>
            <ul class="list-disc ml-6">
                <li><strong>Definition</strong>: Initialization assigns initial values to array elements at the time of declaration or later.</li>
                <li><strong>Methods</strong>:
                    <ul class="list-circle ml-6">
                        <li><strong>At Declaration</strong>:
<pre><code class="language-cpp">data_type array_name[size] = {value1, value2, ..., valueN};</code></pre>
                            <ul class="list-square ml-6">
                                <li>If fewer values are provided than the size, remaining elements are initialized to 0 (for numeric types).</li>
                                <li>If no values are provided, elements may contain garbage values unless explicitly initialized.</li>
                            </ul>
                        </li>
                        <li><strong>After Declaration</strong>: Assign values to individual elements using indices.</li>
                    </ul>
                </li>
                <li><strong>Examples</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    // Initialization at declaration
    int arr1[5] = {1, 2, 3}; // arr1 = {1, 2, 3, 0, 0}
    int arr2[3] = {}; // arr2 = {0, 0, 0}

    // Initialization after declaration
    int arr3[4];
    arr3[0] = 10;
    arr3[1] = 20;
    arr3[2] = 30;
    arr3[3] = 40;

    // Print arr1
    for(int i = 0; i &lt; 5; i++) {
        cout &lt;&lt; arr1[i] &lt;&lt; " "; // Output: 1 2 3 0 0
    }
    cout &lt;&lt; endl;

    return 0;
}</code></pre>
                </li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">4. Processing with Arrays</h3>
            <ul class="list-disc ml-6">
                <li><strong>Definition</strong>: Processing involves performing operations like traversal, searching, sorting, or modifying array elements using loops or algorithms.</li>
                <li><strong>Common Operations</strong>:
                    <ul class="list-circle ml-6">
                        <li><strong>Traversal</strong>: Accessing each element.</li>
                        <li><strong>Searching</strong>: Finding an element (e.g., linear search).</li>
                        <li><strong>Sorting</strong>: Arranging elements in order (e.g., bubble sort).</li>
                        <li><strong>Summing/Averaging</strong>: Calculating sum or average of elements.</li>
                    </ul>
                </li>
                <li><strong>Example (Sum and Average)</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int sum = 0;

    // Traversing and summing
    for(int i = 0; i &lt; 5; i++) {
        sum += arr[i];
    }

    double avg = static_cast&lt;double&gt;(sum) / 5;
    cout &lt;&lt; "Sum: " &lt;&lt; sum &lt;&lt; endl; // Output: 150
    cout &lt;&lt; "Average: " &lt;&lt; avg &lt;&lt; endl; // Output: 30
    return 0;
}</code></pre>
                </li>
                <li><strong>Example (Linear Search)</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    int arr[5] = {5, 2, 8, 1, 9};
    int key = 8;
    bool found = false;

    for(int i = 0; i &lt; 5; i++) {
        if(arr[i] == key) {
            cout &lt;&lt; "Element " &lt;&lt; key &lt;&lt; " found at index " &lt;&lt; i &lt;&lt; endl;
            found = true;
            break;
        }
    }
    if(!found) {
        cout &lt;&lt; "Element not found" &lt;&lt; endl;
    }
    return 0;
}</code></pre>
                </li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">5. Arrays and Functions</h3>
            <ul class="list-disc ml-6">
                <li><strong>Definition</strong>: Arrays can be passed to functions to perform operations. When an array is passed to a function, it is passed by reference (the function works on the original array).</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">void function_name(data_type array_name[], int size);</code></pre>
                </li>
                <li><strong>Key Points</strong>:
                    <ul class="list-circle ml-6">
                        <li>The size of the array is often passed as a separate parameter since arrays decay to pointers in functions.</li>
                        <li>Modifications to the array in the function affect the original array.</li>
                    </ul>
                </li>
                <li><strong>Example (Function to Print Array)</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void printArray(int arr[], int size) {
    for(int i = 0; i &lt; size; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    printArray(arr, 5); // Output: 1 2 3 4 5
    return 0;
}</code></pre>
                </li>
                <li><strong>Example (Function to Modify Array)</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void incrementArray(int arr[], int size) {
    for(int i = 0; i &lt; size; i++) {
        arr[i] += 1; // Modifies original array
    }
}

int main() {
    int arr[3] = {10, 20, 30};
    incrementArray(arr, 3);
    for(int i = 0; i &lt; 3; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " "; // Output: 11 21 31
    }
    return 0;
}</code></pre>
                </li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">6. Multi-dimensional Arrays</h3>
            <ul class="list-disc ml-6">
                <li><strong>Definition</strong>: A multi-dimensional array is an array of arrays, commonly used to represent matrices or tables. The most common type is a 2D array.</li>
                <li><strong>Syntax (2D Array)</strong>:
<pre><code class="language-cpp">data_type array_name[rows][columns];</code></pre>
                </li>
                <li><strong>Initialization</strong>:
                    <ul class="list-circle ml-6">
                        <li>At declaration:
<pre><code class="language-cpp">int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};</code></pre>
                        </li>
                        <li>Nested loops for manual initialization.</li>
                    </ul>
                </li>
                <li><strong>Accessing Elements</strong>: Use two indices, e.g., <code>matrix[i][j]</code>.</li>
                <li><strong>Example (2D Array Traversal)</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};

    // Traversing 2D array
    for(int i = 0; i &lt; 2; i++) {
        for(int j = 0; j &lt; 3; j++) {
            cout &lt;&lt; matrix[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
    // Output:
    // 1 2 3
    // 4 5 6
    return 0;
}</code></pre>
                </li>
                <li><strong>Example (Matrix Addition)</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    int mat1[2][2] = {{1, 2}, {3, 4}};
    int mat2[2][2] = {{5, 6}, {7, 8}};
    int result[2][2];

    // Adding matrices
    for(int i = 0; i &lt; 2; i++) {
        for(int j = 0; j &lt; 2; j++) {
            result[i][j] = mat1[i][j] + mat2[i][j];
        }
    }

    // Printing result
    for(int i = 0; i &lt; 2; i++) {
        for(int j = 0; j &lt; 2; j++) {
            cout &lt;&lt; result[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
    // Output:
    // 6 8
    // 10 12
    return 0;
}</code></pre>
                </li>
                <li><strong>Multi-dimensional Arrays and Functions</strong>:
                    <ul class="list-circle ml-6">
                        <li>For a 2D array, specify the number of columns in the function parameter.</li>
                        <li><strong>Syntax</strong>:
<pre><code class="language-cpp">void function_name(data_type array_name[][columns], int rows);</code></pre>
                        </li>
                        <li><strong>Example</strong>:
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void printMatrix(int matrix[][3], int rows) {
    for(int i = 0; i &lt; rows; i++) {
        for(int j = 0; j &lt; 3; j++) {
            cout &lt;&lt; matrix[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
}

int main() {
    int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
    printMatrix(matrix, 2);
    return 0;
}</code></pre>
                </li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Key Points to Remember</h3>
            <ul class="list-disc ml-6">
                <li>Arrays are zero-indexed in C++.</li>
                <li>Always ensure array indices are within bounds to avoid undefined behavior.</li>
                <li>Arrays passed to functions are passed by reference, so changes persist.</li>
                <li>Multi-dimensional arrays are useful for representing complex data structures like matrices.</li>
                <li>Use loops for efficient array processing.</li>
            </ul>

            <h3 class="text-lg md:text-xl">Practice Questions</h3>
            <ol class="list-decimal ml-6">
                <li>Write a program to find the largest element in a 1D array.</li>
                <li>Create a function to reverse a 1D array.</li>
                <li>Write a program to multiply two 2x2 matrices.</li>
                <li>Implement a function to check if a 1D array is sorted in ascending order.</li>
                <li>Write a program to transpose a 3x3 matrix.</li>
            </ol>
            <p>This note covers the core concepts of arrays in C++ with practical examples, aligned with the provided syllabus. Let me know if you need further clarification or additional examples!</p>
        </section>

        <section id="unit-6" class="section-card">
            <h2 class="text-xl md:text-2xl">Unit 6: Character Handling and Strings in C++</h2>

            <h3 class="text-lg md:text-xl">Key Points</h3>
            <ul class="list-disc ml-6">
                <li>Character handling in C++ involves using character arrays and strings, with both manual and library-based methods.</li>
                <li>It seems likely that strings can be declared as character arrays or using the <code>std::string</code> class, each with different advantages.</li>
                <li>Research suggests that manual string operations like finding length or concatenating require custom code, while library functions like <code>strcpy()</code> and <code>strlen()</code> simplify tasks.</li>
                <li>The evidence leans toward using C++ library functions for safer and more efficient string handling, though manual methods are useful for learning.</li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Declaration and Basics</h3>
            <p>C++ strings can be handled using character arrays, which are null-terminated sequences of characters, or the <code>std::string</code> class for more advanced operations. Declaring a string as a character array looks like <code>char str[20];</code>, while using <code>std::string</code> is <code>std::string str;</code>. Reading strings can be done with <code>std::cin</code> for basic input or <code>std::getline()</code> for lines including spaces.</p>

            <h3 class="text-lg md:text-xl">String Handling Methods</h3>
            <p>Without library functions, you manually perform operations like finding the string length by counting characters until the null terminator, or concatenating by copying characters. With library functions, <code>strcpy()</code> copies strings, <code>strcat()</code> joins them, <code>strlen()</code> gets the length, and <code>strcmp()</code> compares them, all part of the <code>&lt;cstring&gt;</code> header.</p>

            <hr class="my-6 border-t border-gray-300">

            <h2 class="text-xl md:text-2xl">Survey Note: Comprehensive Guide to Character Handling in C++ and Strings</h2>

            <h3 class="text-lg md:text-xl">Introduction to Character Handling in C++</h3>
            <p>Character handling in C++ is a fundamental aspect of programming, involving the manipulation of individual characters and strings. Strings in C++ can be represented in two primary ways: as character arrays (C-style strings) or as objects of the <code>std::string</code> class (C++-style strings). This note, based on the syllabus for Unit-6, covers the declaration of string variables, reading strings, and both manual and library-based string handling, including specific functions like <code>strcpy()</code>, <code>strcat()</code>, <code>strlen()</code>, and <code>strcmp()</code>.</p>

            <h3 class="text-lg md:text-xl">Character Arrays and String Declaration</h3>
            <p>A character array is a sequence of characters stored in contiguous memory locations, terminated by a null character (<code>\0</code>). For example:</p>
            <ul class="list-disc ml-6">
                <li>Declaration: <code>char str[] = "Hello";</code> creates a character array with <code>'H'</code>, <code>'e'</code>, <code>'l'</code>, <code>'l'</code>, <code>'o'</code>, and <code>\0</code>.</li>
                <li>The size must account for the null terminator, ensuring sufficient space for the string.</li>
            </ul>
            <p>Strings can also be declared using the <code>std::string</code> class, part of the C++ Standard Library, which offers dynamic sizing and built-in functions. Examples include:</p>
            <ul class="list-disc ml-6">
                <li><code>char str[20];</code> for a fixed-size character array.</li>
                <li><code>std::string str;</code> for a flexible string object.</li>
            </ul>
            <p>The choice between character arrays and <code>std::string</code> depends on the application's needs, with character arrays being more manual and <code>std::string</code> offering safety and convenience.</p>

            <h3 class="text-lg md:text-xl">Reading Strings</h3>
            <p>Reading strings into variables is crucial for input operations. For character arrays:</p>
            <ul class="list-disc ml-6">
                <li>Use <code>std::cin &gt;&gt; str;</code> for basic input, but it stops at spaces.</li>
                <li>Use <code>std::cin.getline(str, 20);</code> to read a line, including spaces, up to a specified size to prevent buffer overflows.</li>
            </ul>
            <p>For <code>std::string</code>, use:</p>
            <ul class="list-disc ml-6">
                <li><code>std::cin &gt;&gt; str;</code> for simple input.</li>
                <li><code>std::getline(std::cin, str);</code> for reading entire lines, ideal for user input with spaces.</li>
            </ul>
            <p>These methods ensure flexibility in handling input, with <code>std::getline()</code> being particularly useful for reading complete sentences.</p>

            <h3 class="text-lg md:text-xl">String Handling Without Library Functions</h3>
            <p>When working with character arrays without library functions, you must implement string operations manually. The syllabus lists seven operations, each detailed below with examples:</p>

            <h4>1. Finding the Length of the String</h4>
            <ul class="list-disc ml-6">
                <li>Iterate through the array until the null character is found.</li>
                <li>Example:
<pre><code class="language-cpp">int length = 0;
while (str[length] != '\0') {
    length++;
}</code></pre>
                </li>
                <li>This counts characters, excluding the null terminator, giving the string's length.</li>
            </ul>

            <h4>2. String Concatenation</h4>
            <ul class="list-disc ml-6">
                <li>Append one string to another by copying characters, ensuring the destination has enough space.</li>
                <li>Example:
<pre><code class="language-cpp">char dest[50] = "Hello";
char src[] = " World";
int i = 0, j = 0;
while (dest[i] != '\0') i++;
while (src[j] != '\0') {
    dest[i] = src[j];
    i++;
    j++;
}
dest[i] = '\0';</code></pre>
                </li>
                <li>Result: <code>dest</code> becomes "Hello World".</li>
            </ul>

            <h4>3. String Reverse</h4>
            <ul class="list-disc ml-6">
                <li>Swap characters from the start and end, moving inward.</li>
                <li>Example:
<pre><code class="language-cpp">int start = 0;
int end = strlen(str) - 1;  // Manual length calculation needed here
char temp;
while (start &lt; end) {
    temp = str[start];
    str[start] = str[end];
    str[end] = temp;
    start++;
    end--;
}</code></pre>
                </li>
                <li>This reverses the string in place.</li>
            </ul>

            <h4>4. String Copy</h4>
            <ul class="list-disc ml-6">
                <li>Copy characters from the source to the destination, including the null terminator.</li>
                <li>Example:
<pre><code class="language-cpp">char dest[50];
int i = 0;
while (src[i] != '\0') {
    dest[i] = src[i];
    i++;
}
dest[i] = '\0';</code></pre>
                </li>
                <li>Ensures <code>dest</code> is an exact copy of <code>src</code>.</li>
            </ul>

            <h4>5. Combining/Joining Strings Together</h4>
            <ul class="list-disc ml-6">
                <li>Similar to concatenation but may involve multiple strings.</li>
                <li>Example (joining three strings):
<pre><code class="language-cpp">char dest[100] = "Hello";
char src1[] = " ";
char src2[] = "World";
int i = 0, j = 0, k = 0;
while (dest[i] != '\0') i++;
while (src1[j] != '\0') {
    dest[i] = src1[j];
    i++;
    j++;
}
while (src2[k] != '\0') {
    dest[i] = src2[k];
    i++;
    k++;
}
dest[i] = '\0';</code></pre>
                </li>
                <li>Result: <code>dest</code> becomes "Hello World".</li>
            </ul>

            <h4>6. String Comparison</h4>
            <ul class="list-disc ml-6">
                <li>Compare characters lexicographically until a difference is found or the end is reached.</li>
                <li>Example:
<pre><code class="language-cpp">int result = 0;
for (int i = 0; str1[i] != '\0' &amp;&amp; str2[i] != '\0'; i++) {
    if (str1[i] != str2[i]) {
        result = str1[i] - str2[i];
        break;
    }
}
if (result == 0 &amp;&amp; (str1[i] != '\0' || str2[i] != '\0')) {
    result = str1[i] - str2[i];
}</code></pre>
                </li>
                <li>Returns 0 if equal, &lt;0 if <code>str1</code> &lt; <code>str2</code>, &gt;0 if <code>str1</code> &gt; <code>str2</code>.</li>
            </ul>

            <h4>7. Extraction of a String from Another String</h4>
            <ul class="list-disc ml-6">
                <li>Copy a substring by specifying start and end positions.</li>
                <li>Example:
<pre><code class="language-cpp">char source[] = "Hello, World!";
char substring[10];
int start = 7;  // Starting at "World"
int end = 12;
int j = 0;
for (int i = start; i &lt; end; i++) {
    substring[j] = source[i];
    j++;
}
substring[j] = '\0';</code></pre>
                </li>
                <li>Result: <code>substring</code> contains "World".</li>
            </ul>
            <p>These manual operations are educational but can be error-prone, especially with buffer overflows or memory management.</p>

            <h3 class="text-lg md:text-xl">Using C++ String Handling Library Functions</h3>
            <p>C++ provides library functions for string manipulation, particularly for C-style strings, declared in the <code>&lt;cstring&gt;</code> header. The syllabus specifies four functions, detailed below with examples:</p>
            <div class="overflow-x-auto rounded-lg shadow-md">
                <table class="min-w-full bg-white">
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Description</th>
                            <th>Syntax</th>
                            <th>Example Output</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>strcpy()</code></td>
                            <td>Copies one string to another</td>
                            <td><code>strcpy(dest, src)</code></td>
                            <td>Copies "Hello" into <code>dest</code></td>
                        </tr>
                        <tr>
                            <td><code>strcat()</code></td>
                            <td>Concatenates two strings</td>
                            <td><code>strcat(dest, src)</code></td>
                            <td>Appends " World" to "Hello"</td>
                        </tr>
                        <tr>
                            <td><code>strlen()</code></td>
                            <td>Returns the length of a string</td>
                            <td><code>strlen(str)</code></td>
                            <td>Returns 5 for "Hello"</td>
                        </tr>
                        <tr>
                            <td><code>strcmp()</code></td>
                            <td>Compares two strings lexicographically</td>
                            <td><code>strcmp(str1, str2)</code></td>
                            <td>Returns negative for "Hello" &lt; "World"</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <ul class="list-disc ml-6">
                <li><strong><code>strcpy()</code> Example</strong>:
<pre><code class="language-cpp">char dest[20];
char src[] = "Hello";
strcpy(dest, src);  // dest becomes "Hello"</code></pre>
                    <ul class="list-circle ml-6">
                        <li>Note: Ensure <code>dest</code> has enough space to avoid buffer overflows.</li>
                    </ul>
                </li>
                <li><strong><code>strcat()</code> Example</strong>:
<pre><code class="language-cpp">char dest[20] = "Hello";
char src[] = " World";
strcat(dest, src);  // dest becomes "Hello World"</code></pre>
                    <ul class="list-circle ml-6">
                        <li>Ensure <code>dest</code> has sufficient space for the concatenated result.</li>
                    </ul>
                </li>
                <li><strong><code>strlen()</code> Example</strong>:
<pre><code class="language-cpp">char str[] = "Hello";
int len = strlen(str);  // len is 5</code></pre>
                    <ul class="list-circle ml-6">
                        <li>Excludes the null terminator in the count.</li>
                    </ul>
                </li>
                <li><strong><code>strcmp()</code> Example</strong>:
<pre><code class="language-cpp">char str1[] = "Hello";
char str2[] = "World";
int result = strcmp(str1, str2);  // result is negative</code></pre>
                    <ul class="list-circle ml-6">
                        <li>Returns 0 if equal, &lt;0 if <code>str1</code> &lt; <code>str2</code>, &gt;0 if <code>str1</code> &gt; <code>str2</code>.</li>
                    </ul>
                </li>
            </ul>
            <p>These functions are efficient but require careful use to prevent issues like buffer overflows, especially with <code>strcpy()</code> and <code>strcat()</code>.</p>

            <h3 class="text-lg md:text-xl">Comparative Analysis</h3>
            <p>Manual string handling is useful for understanding the underlying mechanics but is less efficient and more prone to errors. Library functions, while convenient, are part of the C standard library and work with C-style strings, not <code>std::string</code>. For modern C++ programming, <code>std::string</code> is recommended for its safety features, such as automatic memory management and built-in methods like <code>append()</code> or <code>compare()</code>.</p>

            <h3 class="text-lg md:text-xl">Conclusion</h3>
            <p>This note covers all aspects of character handling and strings as per the syllabus, providing a balance between manual operations and library functions. It highlights the importance of understanding both approaches, with a nod to the safer, more efficient <code>std::string</code> class for practical applications.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Key Citations</h3>
            <ul class="list-disc ml-6">
                <li><a href="https://www.guru99.com/stdstring-class-in-cpp.html" target="_blank" class="text-blue-600 hover:underline">Deep dive into C++ string functions and operations</a></li>
                <li><a href="https://www.geeksforgeeks.org/strings-in-cpp/" target="_blank" class="text-blue-600 hover:underline">Strings in C++ comprehensive educational platform</a></li>
            </ul>
        </section>

        <section id="unit-7" class="section-card">
            <h2 class="text-xl md:text-2xl">Unit 7: Structures and Unions in C++</h2>

            <h3 class="text-lg md:text-xl">Key Points</h3>
            <ul class="list-disc ml-6">
                <li>Structures in C++ group different data types, while unions share memory for different types, with only one active at a time.</li>
                <li>Research suggests structures are initialized and accessed using dot (.) operator, while unions require careful management to avoid undefined behavior.</li>
                <li>It seems likely that arrays can be part of structures or form arrays of structures, enhancing data organization.</li>
                <li>The evidence leans toward <code>typedef</code> simplifying type declarations, especially with structures, for better code readability.</li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Declaration and Initialization</h3>
            <p>Structures are declared with <code>struct</code>, grouping variables like <code>int</code>, <code>char</code>, and <code>float</code>. For example, a <code>Student</code> structure might include <code>roll_number</code>, <code>name</code>, and <code>marks</code>. Initialization can be done at declaration, like <code>Student s1 = {101, "John Doe", 85.5}</code>, ensuring all members are set to avoid undefined behavior.</p>

            <h3 class="text-lg md:text-xl">Referencing and Arrays</h3>
            <p>Access structure members with the dot operator, e.g., <code>s1.roll_number</code>. Arrays of structures store multiple instances, like an array of three students, while structures can contain arrays, such as grades within a <code>Course</code> structure, improving data management.</p>

            <h3 class="text-lg md:text-xl">Unions and Type Definitions</h3>
            <p>Unions share memory, so only one member (e.g., <code>int i</code> or <code>float f</code>) is active at once, requiring careful access to prevent errors. The <code>typedef</code> keyword, like <code>typedef struct { ... } Student</code>, simplifies declaring structure variables, enhancing code clarity.</p>

            <hr class="my-6 border-t border-gray-300">

            <h2 class="text-xl md:text-2xl">Detailed Note on C++ Programming: Unit-7 Structure and Union</h2>
            <p>This comprehensive note covers the C++ programming syllabus for Unit-7: Structure and Union, including Declaration of Structure, Initialization of Structure, Referencing Structure Elements, Arrays of Structures, Arrays within a Structure, Unions, and the <code>typedef</code> keyword. Each concept is explained in detail with examples, syntax, and additional insights, aiming to provide a thorough understanding for learners and professionals alike.</p>

            <h3 class="text-lg md:text-xl">Introduction to Structures and Unions in C++</h3>
            <p>In C++, structures (structs) and unions are user-defined data types that facilitate grouping of different data types under a single name. Structures are ideal for storing multiple related data items simultaneously, while unions allow efficient memory usage by sharing the same memory space among different types, with only one member active at a time. These features are essential for organizing and managing complex data in C++ programs.</p>

            <h3 class="text-lg md:text-xl">1. Declaration of Structure</h3>
            <p>A structure is declared using the <code>struct</code> keyword, enabling the grouping of variables of different types. This is particularly useful for representing real-world entities with multiple attributes.</p>
            <ul class="list-disc ml-6">
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">struct StructureName {
    type member1;
    type member2;
    // ...
};</code></pre>
                </li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">struct Student {
    int roll_number;
    char name[50];
    float marks;
};</code></pre>
                </li>
                <li><strong>Key Points</strong>:
                    <ul class="list-circle ml-6">
                        <li>Structures can include members of various data types, such as integers, floats, characters, arrays, and even other structures.</li>
                        <li>In C++, unlike C, structures can also include member functions, enhancing their functionality. For instance:
<pre><code class="language-cpp">struct Rectangle {
    int length;
    int breadth;
    int getArea() {
        return length * breadth;
    }
};</code></pre>
                        </li>
                        <li>The declaration does not allocate memory; variables must be created separately to use the structure.</li>
                    </ul>
                </li>
            </ul>

            <h3 class="text-lg md:text-xl">2. Initialization of Structure</h3>
            <p>Structures can be initialized at the time of declaration or later using assignment, ensuring all members are set to known values to avoid undefined behavior.</p>
            <ul class="list-disc ml-6">
                <li><strong>Syntax</strong>:
                    <ul class="list-circle ml-6">
                        <li>At declaration:
<pre><code class="language-cpp">struct Student s1 = {value1, value2, value3};</code></pre>
                        </li>
                        <li>Later:
<pre><code class="language-cpp">struct Student s1;
s1.member1 = value1;
s1.member2 = value2;
// ...</code></pre>
                        </li>
                    </ul>
                </li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">struct Student s1 = {101, "John Doe", 85.5};</code></pre>
                </li>
                <li><strong>Key Points</strong>:
                    <ul class="list-circle ml-6">
                        <li>Initialization must match the order and type of the structure's members.</li>
                        <li>Failing to initialize all members may lead to garbage values, causing potential errors.</li>
                    </ul>
                </li>
            </ul>

            <h3 class="text-lg md:text-xl">3. Referencing Structure Elements</h3>
            <p>Members of a structure are accessed using the dot (.) operator, providing direct access to individual components.</p>
            <ul class="list-disc ml-6">
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">structure_variable.member_name</code></pre>
                </li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">struct Student s1 = {101, "John Doe", 85.5};
cout &lt;&lt; s1.roll_number &lt;&lt; endl;  // Outputs: 101
cout &lt;&lt; s1.name &lt;&lt; endl;         // Outputs: John Doe
cout &lt;&lt; s1.marks &lt;&lt; endl;        // Outputs: 85.5</code></pre>
                </li>
                <li><strong>Key Points</strong>:
                    <ul class="list-circle ml-6">
                        <li>The dot operator (.) is used for direct member access.</li>
                        <li>For pointers to structures, the arrow operator (->) is used:
<pre><code class="language-cpp">struct Student *ptr = &amp;s1;
cout &lt;&lt; ptr-&gt;roll_number &lt;&lt; endl;</code></pre>
                        </li>
                        <li>This method ensures efficient access to structure data.</li>
                    </ul>
                </li>
            </ul>

            <h3 class="text-lg md:text-xl">4. Arrays of Structures</h3>
            <p>Arrays of structures allow storing multiple instances of the same structure type, useful for managing collections of similar data.</p>
            <ul class="list-disc ml-6">
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">struct Student students[size] = {
    {value1, value2, value3},
    {value4, value5, value6},
    // ...
};</code></pre>
                </li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">struct Student students[3] = {
    {101, "John Doe", 85.5},
    {102, "Jane Smith", 90.0},
    {103, "Bob Johnson", 78.5}
};</code></pre>
                </li>
                <li><strong>Key Points</strong>:
                    <ul class="list-circle ml-6">
                        <li>Each element of the array is a structure variable, accessible via index.</li>
                        <li>Accessing members:
<pre><code class="language-cpp">cout &lt;&lt; students[0].name &lt;&lt; endl;  // Outputs: John Doe</code></pre>
                        </li>
                        <li>This is particularly useful for handling lists of records, such as student databases.</li>
                    </ul>
                </li>
            </ul>

            <h3 class="text-lg md:text-xl">5. Arrays within a Structure</h3>
            <p>A structure can contain an array as one of its members, allowing for more complex data representations, such as lists of grades or scores.</p>
            <ul class="list-disc ml-6">
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">struct StructureName {
    type array_name[size];
    // ...
};</code></pre>
                </li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">struct Course {
    char course_name[50];
    int grades[5];
};

struct Course c1 = {"Mathematics", {85, 90, 78, 92, 88}};</code></pre>
                </li>
                <li><strong>Key Points</strong>:
                    <ul class="list-circle ml-6">
                        <li>The array within the structure is accessed like any other array:
<pre><code class="language-cpp">cout &lt;&lt; c1.grades[0] &lt;&lt; endl;  // Outputs: 85</code></pre>
                        </li>
                        <li>Proper initialization is crucial to avoid undefined behavior, especially for arrays.</li>
                    </ul>
                </li>
            </ul>

            <h3 class="text-lg md:text-xl">6. Unions</h3>
            <p>A union is a user-defined type that allows storing different data types in the same memory location, with only one member active at a time. This is memory-efficient but requires careful management to avoid errors.</p>
            <ul class="list-disc ml-6">
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">union UnionName {
    type member1;
    type member2;
    // ...
};</code></pre>
                </li>
                <li><strong>Example</strong>:
<pre><code class="language-cpp">union Data {
    int i;
    float f;
    char str[20];
};

union Data d;
d.i = 10;  // Now 'i' is active
cout &lt;&lt; d.i &lt;&lt; endl;  // Outputs: 10
d.f = 3.14;  // Now 'f' is active
cout &lt;&lt; d.f &lt;&lt; endl;  // Outputs: 3.14</code></pre>
                </li>
                <li><strong>Key Points</strong>:
                    <ul class="list-circle ml-6">
                        <li>All members share the same memory space, with the union's size equal to the largest member.</li>
                        <li>Accessing a member that was not last written to results in undefined behavior, a critical consideration.</li>
                        <li>Unions cannot have virtual functions, base classes, or non-static data members of reference types.</li>
                        <li><strong>Advanced Concept: Member Lifetime</strong>:
                            <ul class="list-square ml-6">
                                <li>When switching between members, especially for classes with constructors/destructors, manual management is required:
<pre><code class="language-cpp">union S {
    std::string str;
    std::vector&lt;int&gt; vec;
    ~S() {}
};

S s = {"Hello, world"};
s.str.~basic_string();  // End lifetime of str
new (&amp;s.vec) std::vector&lt;int&gt;;  // Start lifetime of vec</code></pre>
                                </li>
                            </ul>
                        </li>
                        <li><strong>Anonymous Unions</strong>:
                            <ul class="list-square ml-6">
                                <li>Unions without a name inject members into the enclosing scope, with restrictions like no member functions:
<pre><code class="language-cpp">union { int a; const char* p; };
a = 1;  // Directly accesses 'a'
p = "Jennifer";  // Directly accesses 'p'</code></pre>
                                </li>
                                <li>All members must be public, and no static members are allowed.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>

            <h3 class="text-lg md:text-xl">7. typedef Keyword</h3>
            <p>The <code>typedef</code> keyword defines an alias for an existing type, enhancing code readability and simplifying declarations, especially for structures.</p>
            <ul class="list-disc ml-6">
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">typedef existing_type new_name;</code></pre>
                </li>
                <li><strong>Example with Structure</strong>:
<pre><code class="language-cpp">typedef struct {
    int roll_number;
    char name[50];
    float marks;
} Student;

Student s1 = {101, "John Doe", 85.5};</code></pre>
                </li>
                <li><strong>Key Points</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>typedef</code> can be used with any data type, not just structures, to create aliases.</li>
                        <li>It simplifies variable declarations, particularly for complex types, improving code clarity.</li>
                        <li>Example without <code>typedef</code>:
<pre><code class="language-cpp">struct Student {
    int roll_number;
    char name[50];
    float marks;
};
struct Student s1 = {101, "John Doe", 85.5};</code></pre>
                        </li>
                    </ul>
                </li>
            </ul>

            <h3 class="text-lg md:text-xl">Additional Insights and Best Practices</h3>
            <ul class="list-disc ml-6">
                <li><strong>Structures vs. Unions</strong>:
                    <ul class="list-circle ml-6">
                        <li>Structures are used when storing multiple related data items simultaneously is necessary, such as student records.</li>
                        <li>Unions are ideal for scenarios requiring different data types in the same memory, like handling different data formats (e.g., integer or string), but only one at a time.</li>
                        <li>Table comparing key differences:
                            <div class="overflow-x-auto rounded-lg shadow-md">
                                <table class="min-w-full bg-white">
                                    <thead>
                                        <tr>
                                            <th>Feature</th>
                                            <th>Structure</th>
                                            <th>Union</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Memory Allocation</td>
                                            <td>Separate memory for each member</td>
                                            <td>Shared memory, size of largest member</td>
                                        </tr>
                                        <tr>
                                            <td>Active Members</td>
                                            <td>All members can be active</td>
                                            <td>Only one member active at a time</td>
                                        </tr>
                                        <tr>
                                            <td>Use Case</td>
                                            <td>Grouping related data</td>
                                            <td>Memory-efficient data sharing</td>
                                        </tr>
                                        <tr>
                                            <td>Access</td>
                                            <td>Dot operator (.)</td>
                                            <td>Dot operator (.), with care</td>
                                        </tr>
                                        <tr>
                                            <td>Example Size</td>
                                            <td>Sum of all members + padding</td>
                                            <td>Size of largest member</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </li>
                    </ul>
                </li>
                <li><strong>Common Pitfalls</strong>:
                    <ul class="list-circle ml-6">
                        <li>For structures, ensure all members are initialized to avoid undefined behavior.</li>
                        <li>For unions, always ensure you are accessing the active member to prevent errors.</li>
                        <li>When using arrays within structures or arrays of structures, pay attention to memory allocation and initialization to manage resources effectively.</li>
                    </ul>
                </li>
                <li><strong>Practical Example</strong>:
                    <p>A program demonstrating structures and unions:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Student {
    int roll_number;
    char name[50];
    float marks;
};

union Data {
    int i;
    float f;
    char str[20];
};

int main() {
    Student s1 = {101, "John Doe", 85.5};
    cout &lt;&lt; "Student Name: " &lt;&lt; s1.name &lt;&lt; endl;
    cout &lt;&lt; "Roll Number: " &lt;&lt; s1.roll_number &lt;&lt; endl;
    cout &lt;&lt; "Marks: " &lt;&lt; s1.marks &lt;&lt; endl;

    Data d;
    d.i = 10;
    cout &lt;&lt; "Union Integer: " &lt;&lt; d.i &lt;&lt; endl;
    d.f = 3.14;
    cout &lt;&lt; "Union Float: " &lt;&lt; d.f &lt;&lt; endl;

    return 0;
}</code></pre>
                    <p>This example illustrates how structures store multiple data points and unions manage different types in shared memory, highlighting their practical application.</p>
                </li>
            </ul>

            <h3 class="text-lg md:text-xl">Conclusion</h3>
            <p>Structures and unions are powerful tools in C++ for organizing and managing data. Structures facilitate grouping related data, while unions enable efficient memory usage by sharing space among different types. Understanding their declaration, initialization, and usage, along with advanced concepts like member lifetime in unions, is crucial for effective C++ programming. The <code>typedef</code> keyword further enhances code readability, making it easier to work with complex types.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Key Citations</h3>
            <ul class="list-disc ml-6">
                <li><a href="https://www.geeksforgeeks.org/structures-unions-and-enumerations-in-cpp/" target="_blank" class="text-blue-600 hover:underline">Structures, Unions and Enumerations in C++</a></li>
                <li><a href="https://www.geeksforgeeks.org/cpp-unions/" target="_blank" class="text-blue-600 hover:underline">C++ Unions</a></li>
                <li><a href="https://www.geeksforgeeks.org/difference-between-structure-and-union-in-c/" target="_blank" class="text-blue-600 hover:underline">Difference Between Structure and Union in C</a></li>
                <li><a href="https://www.geeksforgeeks.org/c-unions/" target="_blank" class="text-blue-600 hover:underline">C Unions</a></li>
                <li><a href="https://www.shiksha.com/online-courses/articles/difference-between-structure-and-union-in-c/" target="_blank" class="text-blue-600 hover:underline">Understanding the Difference Between Structure and Union in C</a></li>
                <li><a href="https://www.w3schools.com/cpp/cpp_structs.asp" target="_blank" class="text-blue-600 hover:underline">C++ Structures (struct)</a></li>
                <li><a href="https://www.informit.com/articles/article.aspx?p=31783&seqNum=2" target="_blank" class="text-blue-600 hover:underline">Structures and Unions Understanding C++ Program Structure</a></li>
                <li><a href="https://en.cppreference.com/w/cpp/language/union" target="_blank" class="text-blue-600 hover:underline">Union declaration - cppreference.com</a></li>
                <li><a href="https://www.tpointtech.com/overview-of-structures-and-unions-in-c" target="_blank" class="text-blue-600 hover:underline">Overview of Structures and Unions in C - Tpoint Tech</a></li>
            </ul>
        </section>

        <section id="unit-8" class="section-card">
            <h2 class="text-xl md:text-2xl">Unit 8: Data File Handling in C++</h2>

            <h3 class="text-lg md:text-xl">Introduction to Data File Handling in C++</h3>
            <p>Data file handling in C++ is a crucial aspect of programming that enables applications to store, retrieve, and manipulate data persistently on storage devices (e.g., hard disks). Unlike data stored in variables, which is temporary and lost when a program terminates, data stored in files persists across program executions. File handling allows programs to read from and write to files, supporting both text and binary formats. This note covers input/output operations on files, opening and closing files, character-based operations using <code>put()</code> and <code>get()</code>, and binary file operations using <code>read()</code> and <code>write()</code> functions, as outlined in the syllabus.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">1. Input/Output Operations on Files</h3>
            <p>Input/output (I/O) operations on files in C++ are facilitated through the <code>&lt;fstream&gt;</code> library, which provides classes and functions to handle file operations. Files are used to store data permanently, and C++ supports two primary types of file operations:</p>
            <ul class="list-disc ml-6">
                <li><strong>Text File Operations</strong>: Data is stored as human-readable text (e.g., characters, strings).</li>
                <li><strong>Binary File Operations</strong>: Data is stored in binary format, which is more compact and efficient for storing complex data like objects or numerical data.</li>
            </ul>
            <p>The <code>&lt;fstream&gt;</code> library includes three main classes for file handling:</p>
            <ul class="list-disc ml-6">
                <li><strong><code>ofstream</code></strong>: Used for output operations (writing to files).</li>
                <li><strong><code>ifstream</code></strong>: Used for input operations (reading from files).</li>
                <li><strong><code>fstream</code></strong>: Supports both input and output operations.</li>
            </ul>
            <p>These classes inherit from the <code>iostream</code> class, allowing the use of familiar operators like <code>&lt;&lt;</code> (for output) and <code>&gt;&gt;</code> (for input).</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">2. Opening and Closing of Files</h3>
            <p>Before performing any operations on a file, it must be opened to establish a connection between the program and the file. After operations are complete, the file must be closed to free system resources and ensure data integrity.</p>

            <h4>Opening a File</h4>
            <p>A file can be opened using the <code>open()</code> member function of the <code>ofstream</code>, <code>ifstream</code>, or <code>fstream</code> classes. The syntax is:</p>
<pre><code class="language-cpp">void open(const char* filename, ios::openmode mode);</code></pre>
            <ul class="list-disc ml-6">
                <li><strong>filename</strong>: The name (and optionally the path) of the file to be opened.</li>
                <li><strong>mode</strong>: Specifies the mode in which the file is opened. Common modes include:
                    <ul class="list-circle ml-6">
                        <li><code>ios::in</code>: Open for reading (default for <code>ifstream</code>).</li>
                        <li><code>ios::out</code>: Open for writing (default for <code>ofstream</code>).</li>
                        <li><code>ios::app</code>: Append data to the end of the file.</li>
                        <li><code>ios::ate</code>: Seek to the end of the file upon opening.</li>
                        <li><code>ios::trunc</code>: Truncate the file if it already exists.</li>
                        <li><code>ios::binary</code>: Open the file in binary mode (default is text mode).</li>
                    </ul>
                </li>
            </ul>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;
using namespace std;

int main() {
    ofstream outfile;
    outfile.open("example.txt", ios::out); // Open file for writing
    if (outfile.is_open()) {
        outfile &lt;&lt; "Hello, File Handling!";
        outfile.close(); // Close the file
    }
    return 0;
}</code></pre>
            <p>Alternatively, a file can be opened directly when declaring the file stream object:</p>
<pre><code class="language-cpp">ofstream outfile("example.txt", ios::out);</code></pre>

            <h4>Closing a File</h4>
            <p>A file is closed using the <code>close()</code> member function, which flushes any buffered data to the file and releases the file handle. It is good practice to check if the file was opened successfully before performing operations and to close it afterward.</p>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">outfile.close();</code></pre>

            <h4>Checking File Status</h4>
            <p>To verify if a file was opened successfully, use the <code>is_open()</code> function:</p>
<pre><code class="language-cpp">if (outfile.is_open()) {
    // Perform file operations
} else {
    cout &lt;&lt; "Error opening file!" &lt;&lt; endl;
}</code></pre>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">3. Writing and Reading Characters Using <code>put()</code> and <code>get()</code></h3>
            <p>The <code>put()</code> and <code>get()</code> functions are used for character-based I/O operations, primarily for text files. These functions allow reading and writing individual characters, making them suitable for precise control over file content.</p>

            <h4>Writing Characters Using <code>put()</code></h4>
            <p>The <code>put()</code> function writes a single character to a file. It is a member function of the <code>ofstream</code> or <code>fstream</code> class.</p>
            <p><strong>Syntax</strong>:</p>
<pre><code class="language-cpp">ofstream&amp; put(char ch);</code></pre>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;
using namespace std;

int main() {
    ofstream outfile("example.txt");
    if (outfile.is_open()) {
        outfile.put('A'); // Write character 'A' to the file
        outfile.put('\n'); // Write newline
        outfile.close();
    }
    return 0;
}</code></pre>

            <h4>Reading Characters Using <code>get()</code></h4>
            <p>The <code>get()</code> function reads a single character from a file. It is a member function of the <code>ifstream</code> or <code>fstream</code> class.</p>
            <p><strong>Syntax</strong>:</p>
<pre><code class="language-cpp">int get();</code></pre>
            <p>The <code>get()</code> function returns the ASCII value of the character read or <code>EOF</code> (end-of-file) if no more characters are available.</p>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;
using namespace std;

int main() {
    ifstream infile("example.txt");
    char ch;
    if (infile.is_open()) {
        while ((ch = infile.get()) != EOF) { // Read until end of file
            cout &lt;&lt; ch; // Display character
        }
        infile.close();
    }
    return 0;
}</code></pre>
            <p><strong>Note</strong>: The <code>get()</code> function can also be used to read multiple characters into a buffer, but for single-character reading, the above form is common.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">4. Binary Input/Output File Operations Using <code>read()</code> and <code>write()</code></h3>
            <p>Binary file operations involve reading and writing data in its raw binary form, which is useful for storing complex data structures (e.g., objects, arrays) without converting them to text. The <code>read()</code> and <code>write()</code> functions are used for binary I/O.</p>

            <h4>Writing to a Binary File Using <code>write()</code></h4>
            <p>The <code>write()</code> function writes a block of data to a file. It is typically used with objects or arrays and requires the file to be opened in binary mode (<code>ios::binary</code>).</p>
            <p><strong>Syntax</strong>:</p>
<pre><code class="language-cpp">ostream&amp; write(const char* buffer, streamsize size);</code></pre>
            <ul class="list-disc ml-6">
                <li><strong>buffer</strong>: Pointer to the memory location containing the data to write.</li>
                <li><strong>size</strong>: Number of bytes to write.</li>
            </ul>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;
using namespace std;

struct Student {
    int rollNo;
    char name[20];
};

int main() {
    ofstream outfile("students.dat", ios::binary);
    Student s = {1, "John"};
    if (outfile.is_open()) {
        outfile.write((char*)&amp;s, sizeof(Student)); // Write object to file
        outfile.close();
    }
    return 0;
}</code></pre>

            <h4>Reading from a Binary File Using <code>read()</code></h4>
            <p>The <code>read()</code> function reads a block of data from a file into a buffer. Like <code>write()</code>, it requires the file to be opened in binary mode.</p>
            <p><strong>Syntax</strong>:</p>
<pre><code class="language-cpp">istream&amp; read(char* buffer, streamsize size);</code></pre>
            <ul class="list-disc ml-6">
                <li><strong>buffer</strong>: Pointer to the memory location where the data will be stored.</li>
                <li><strong>size</strong>: Number of bytes to read.</li>
            </ul>
            <p><strong>Example</strong>:</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;
using namespace std;

struct Student {
    int rollNo;
    char name[20];
};

int main() {
    ifstream infile("students.dat", ios::binary);
    Student s;
    if (infile.is_open()) {
        infile.read((char*)&amp;s, sizeof(Student)); // Read object from file
        cout &lt;&lt; "Roll No: " &lt;&lt; s.rollNo &lt;&lt; ", Name: " &lt;&lt; s.name &lt;&lt; endl;
        infile.close();
    }
    return 0;
}</code></pre>

            <h4>Key Points for Binary File Operations</h4>
            <ul class="list-disc ml-6">
                <li>Binary files are more efficient for storing large datasets or complex data structures because they avoid text formatting overhead.</li>
                <li>Always specify <code>ios::binary</code> when opening files for binary operations to prevent issues with newline characters or other text-specific translations.</li>
                <li>The <code>sizeof</code> operator is used to determine the size of the data block for <code>read()</code> and <code>write()</code> operations.</li>
                <li>Ensure the structure being read or written does not contain pointers or virtual functions, as they may lead to undefined behavior.</li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Additional Considerations</h3>
            <ul class="list-disc ml-6">
                <li><strong>Error Handling</strong>: Always check if a file was opened successfully using <code>is_open()</code> or by testing the stream object directly (e.g., <code>if (outfile)</code>). Handle errors gracefully to avoid crashes.</li>
                <li><strong>File Positioning</strong>: Use <code>seekg()</code> (for input) and <code>seekp()</code> (for output) to move the file pointer to a specific position in the file for random access.</li>
                <li><strong>EOF Detection</strong>: When reading files, check for the end-of-file condition using <code>eof()</code> or by checking the return value of functions like <code>get()</code> or <code>read()</code>.</li>
                <li><strong>File Modes</strong>: Combine modes (e.g., <code>ios::in | ios::out | ios::binary</code>) using the bitwise OR operator (<code>|</code>) for flexible file access.</li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Example Program Combining All Concepts</h3>
            <p>Below is a comprehensive example demonstrating file opening, closing, character-based I/O, and binary I/O:</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;
using namespace std;

struct Record {
    int id;
    char name[20];
};

int main() {
    // Text file: Writing and reading characters
    ofstream txtOut("text.txt");
    if (txtOut.is_open()) {
        txtOut.put('X'); // Write single character
        txtOut &lt;&lt; " Hello, World!"; // Write string
        txtOut.close();
    }

    ifstream txtIn("text.txt");
    if (txtIn.is_open()) {
        char ch;
        while ((ch = txtIn.get()) != EOF) {
            cout &lt;&lt; ch; // Read and display characters
        }
        txtIn.close();
    }

    cout &lt;&lt; endl;

    // Binary file: Writing and reading a structure
    ofstream binOut("data.dat", ios::binary);
    Record r = {101, "Alice"};
    if (binOut.is_open()) {
        binOut.write((char*)&amp;r, sizeof(Record)); // Write binary data
        binOut.close();
    }

    ifstream binIn("data.dat", ios::binary);
    Record r2;
    if (binIn.is_open()) {
        binIn.read((char*)&amp;r2, sizeof(Record)); // Read binary data
        cout &lt;&lt; "ID: " &lt;&lt; r2.id &lt;&lt; ", Name: " &lt;&lt; r2.name &lt;&lt; endl;
        binIn.close();
    }

    return 0;
}</code></pre>
            <p><strong>Output</strong>:</p>
<pre><code>X Hello, World!
ID: 101, Name: Alice</code></pre>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">Summary</h3>
            <p>Data file handling in C++ is a powerful feature that enables persistent data storage and retrieval. The <code>&lt;fstream&gt;</code> library provides the tools to open, close, read, and write files in both text and binary formats. The <code>put()</code> and <code>get()</code> functions handle character-based I/O, while <code>read()</code> and <code>write()</code> manage binary data, making them ideal for complex data structures. Proper error handling, file mode selection, and resource management (opening/closing files) are critical for robust file handling. Understanding these concepts allows programmers to build applications that efficiently manage data across sessions.</p>
        </section>

        <section id="unit-9" class="section-card">
            <h2 class="text-xl md:text-2xl">Unit 9: Concept of Objects and Classes in C++ Programming</h2>

            <h3 class="text-lg md:text-xl">1. Introduction to Object-Oriented Programming (OOP)</h3>
            <p>C++ is a powerful programming language that supports <strong>Object-Oriented Programming (OOP)</strong>, a paradigm that organizes code into objects, which are instances of classes. OOP emphasizes modularity, reusability, and encapsulation, making it easier to manage complex programs. The core concepts of OOP in C++ include <strong>classes</strong>, <strong>objects</strong>, <strong>encapsulation</strong>, <strong>inheritance</strong>, <strong>polymorphism</strong>, and <strong>abstraction</strong>. This note focuses on the foundational concepts of <strong>objects</strong>, <strong>classes</strong>, and <strong>member functions</strong> as outlined in Unit-9.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">2. Concept of Objects</h3>
            <ul class="list-disc ml-6">
                <li><strong>Definition</strong>: An object is a real-world entity that has <strong>attributes</strong> (data) and <strong>behavior</strong> (functions). In C++, an object is an instance of a class.</li>
                <li><strong>Characteristics</strong>:
                    <ul class="list-circle ml-6">
                        <li><strong>State</strong>: Represented by attributes (data members) that hold the object's properties.</li>
                        <li><strong>Behavior</strong>: Represented by methods (member functions) that define what the object can do.</li>
                        <li><strong>Identity</strong>: Each object has a unique identity, distinguishing it from other objects.</li>
                    </ul>
                </li>
                <li><strong>Example</strong>: Consider a "Car" as an object:
                    <ul class="list-circle ml-6">
                        <li><strong>State</strong>: Color, model, speed.</li>
                        <li><strong>Behavior</strong>: Accelerate, brake, turn.</li>
                        <li><strong>Identity</strong>: A specific car (e.g., "Toyota Corolla with license plate XYZ123").</li>
                    </ul>
                </li>
            </ul>
            <p>In C++, objects are created from classes, and they occupy memory to store their data and references to their behaviors.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">3. Concept of Classes</h3>
            <ul class="list-disc ml-6">
                <li><strong>Definition</strong>: A class is a user-defined data type that acts as a blueprint for creating objects. It defines the properties (data members) and behaviors (member functions) that the objects created from the class will have.</li>
                <li><strong>Syntax</strong>:
<pre><code class="language-cpp">class ClassName {
public:
    // Data members (variables)
    // Member functions (methods)
};</code></pre>
                    <ul class="list-circle ml-6">
                        <li><strong>ClassName</strong>: The name of the class (e.g., <code>Car</code>).</li>
                        <li><strong>public</strong>: An access specifier that determines the visibility of class members (other specifiers are <code>private</code> and <code>protected</code>).</li>
                        <li><strong>Data Members</strong>: Variables that hold the state of the object.</li>
                        <li><strong>Member Functions</strong>: Functions that define the behavior of the object.</li>
                    </ul>
                </li>
            </ul>
            <p><strong>Purpose</strong>: Classes enable encapsulation, bundling related data and functions together, and provide a template for creating multiple objects with similar characteristics.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">4. Structure vs. Class in C++</h3>
            <p>While both <strong>structures</strong> and <strong>classes</strong> are used to define user-defined data types in C++, they have key differences:</p>
            <div class="overflow-x-auto rounded-lg shadow-md">
                <table class="min-w-full bg-white">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Structure</th>
                            <th>Class</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Default Access Specifier</strong></td>
                            <td>Members are <code>public</code> by default.</td>
                            <td>Members are <code>private</code> by default.</td>
                        </tr>
                        <tr>
                            <td><strong>Purpose</strong></td>
                            <td>Primarily used for grouping data.</td>
                            <td>Used for implementing OOP concepts like encapsulation, inheritance, etc.</td>
                        </tr>
                        <tr>
                            <td><strong>Member Functions</strong></td>
                            <td>Rarely includes member functions.</td>
                            <td>Commonly includes member functions to define behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>Usage</strong></td>
                            <td>Suitable for simple data storage.</td>
                            <td>Suitable for complex objects with data and behavior.</td>
                        </tr>
                        <tr>
                            <td><strong>Inheritance</strong></td>
                            <td>Supports inheritance but rarely used.</td>
                            <td>Commonly used for inheritance and polymorphism.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <ul class="list-disc ml-6">
                <li><strong>Example of a Structure</strong>:
<pre><code class="language-cpp">struct Student {
    int rollNo;
    char name[50];
    float marks;
};</code></pre>
                    <p>Here, <code>Student</code> groups data but typically does not include functions.</p>
                </li>
                <li><strong>Example of a Class</strong>:
<pre><code class="language-cpp">class Student {
public:
    int rollNo;
    string name;
    float marks;
    void display() {
        cout &lt;&lt; "Roll No: " &lt;&lt; rollNo &lt;&lt; ", Name: " &lt;&lt; name &lt;&lt; ", Marks: " &lt;&lt; marks &lt;&lt; endl;
    }
};</code></pre>
                    <p>The <code>Student</code> class includes both data (<code>rollNo</code>, <code>name</code>, <code>marks</code>) and behavior (<code>display</code> function).</p>
                </li>
            </ul>
            <p><strong>Key Difference</strong>: A class is more aligned with OOP principles, allowing encapsulation and abstraction, while a structure is simpler and primarily used for data aggregation. In modern C++, the distinction is minimal since both can support similar features, but classes are preferred for OOP.</p>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">5. Member Functions in Classes</h3>
            <ul class="list-disc ml-6">
                <li><strong>Definition</strong>: Member functions are functions defined within a class that operate on the class's data members. They define the behavior of objects created from the class.</li>
                <li><strong>Types of Member Functions</strong>:
                    <ul class="list-circle ml-6">
                        <li><strong>Normal Member Functions</strong>: Defined inside the class and can access the class's data members.</li>
                        <li><strong>Constructor</strong>: A special member function used to initialize objects.</li>
                        <li><strong>Destructor</strong>: A special member function used to deallocate resources when an object is destroyed.</li>
                        <li><strong>Static Member Functions</strong>: Belong to the class rather than an object and cannot access non-static members.</li>
                        <li><strong>Inline Functions</strong>: Defined inside the class or explicitly marked as <code>inline</code> for optimization.</li>
                    </ul>
                </li>
                <li><strong>Accessing Member Functions</strong>:
                    <ul class="list-circle ml-6">
                        <li>Member functions are called using the dot operator (<code>.</code>) on an object of the class.</li>
                        <li>Example: <code>objectName.functionName();</code></li>
                    </ul>
                </li>
                <li><strong>Declaration and Definition</strong>:
                    <ul class="list-circle ml-6">
                        <li><strong>Inside the Class</strong>:
<pre><code class="language-cpp">class Example {
public:
    void display() {
        cout &lt;&lt; "This is a member function!" &lt;&lt; endl;
    }
};</code></pre>
                        </li>
                        <li><strong>Outside the Class</strong> (using scope resolution operator <code>::</code>):
<pre><code class="language-cpp">class Example {
public:
    void display(); // Declaration
};
void Example::display() { // Definition
    cout &lt;&lt; "This is a member function!" &lt;&lt; endl;
}</code></pre>
                        </li>
                    </ul>
                </li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">6. Simple Example of a Class with Member Functions</h3>
            <p>Below is a complete example demonstrating the use of a class with data members and member functions in C++:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Car {
private:
    // Data members
    string brand;
    int speed;
    float fuelLevel;

public:
    // Constructor to initialize data members
    Car(string b, int s, float f) {
        brand = b;
        speed = s;
        fuelLevel = f;
    }

    // Member function to display car details
    void displayDetails() {
        cout &lt;&lt; "Brand: " &lt;&lt; brand &lt;&lt; endl;
        cout &lt;&lt; "Speed: " &lt;&lt; speed &lt;&lt; " km/h" &lt;&lt; endl;
        cout &lt;&lt; "Fuel Level: " &lt;&lt; fuelLevel &lt;&lt; " liters" &lt;&lt; endl;
    }

    // Member function to simulate driving
    void drive(int distance) {
        if (fuelLevel &gt; distance / 10.0) {
            fuelLevel -= distance / 10.0; // Assume 10 km per liter
            speed += 10; // Increase speed
            cout &lt;&lt; "Driving " &lt;&lt; distance &lt;&lt; " km. New fuel level: " &lt;&lt; fuelLevel &lt;&lt; " liters, Speed: " &lt;&lt; speed &lt;&lt; " km/h" &lt;&lt; endl;
        } else {
            cout &lt;&lt; "Not enough fuel to drive " &lt;&lt; distance &lt;&lt; " km!" &lt;&lt; endl;
        }
    }

    // Member function to refuel
    void refuel(float liters) {
        fuelLevel += liters;
        cout &lt;&lt; "Refueled " &lt;&lt; liters &lt;&lt; " liters. New fuel level: " &lt;&lt; fuelLevel &lt;&lt; " liters" &lt;&lt; endl;
    }
};

int main() {
    // Creating an object of the Car class
    Car myCar("Toyota", 60, 50.0);

    // Calling member functions
    myCar.displayDetails();
    myCar.drive(100);
    myCar.refuel(20.0);
    myCar.displayDetails();

    return 0;
}</code></pre>
            <p><strong>Explanation of the Example</strong>:</p>
            <ul class="list-disc ml-6">
                <li><strong>Class Definition</strong>: The <code>Car</code> class has three data members (<code>brand</code>, <code>speed</code>, <code>fuelLevel</code>) and three member functions (<code>displayDetails</code>, <code>drive</code>, <code>refuel</code>).</li>
                <li><strong>Access Specifiers</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>private</code>: Data members are private to ensure encapsulation, meaning they cannot be accessed directly outside the class.</li>
                        <li><code>public</code>: Member functions are public, allowing them to be called on objects.</li>
                    </ul>
                </li>
                <li><strong>Constructor</strong>: Initializes the object with specific values for <code>brand</code>, <code>speed</code>, and <code>fuelLevel</code>.</li>
                <li><strong>Member Functions</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>displayDetails()</code>: Outputs the car's attributes.</li>
                        <li><code>drive()</code>: Simulates driving by reducing fuel and increasing speed, with a check for sufficient fuel.</li>
                        <li><code>refuel()</code>: Increases the fuel level.</li>
                    </ul>
                </li>
                <li><strong>Object Creation</strong>: <code>myCar</code> is an object of the <code>Car</code> class, created with initial values.</li>
                <li><strong>Output</strong>:
<pre><code>Brand: Toyota
Speed: 60 km/h
Fuel Level: 50 liters
Driving 100 km. New fuel level: 40 liters, Speed: 70 km/h
Refueled 20 liters. New fuel level: 60 liters
Brand: Toyota
Speed: 70 km/h
Fuel Level: 60 liters</code></pre>
                </li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">7. Key Points to Remember</h3>
            <ul class="list-disc ml-6">
                <li><strong>Classes vs. Objects</strong>: A class is a blueprint, while an object is an instance of that blueprint.</li>
                <li><strong>Encapsulation</strong>: Achieved by using access specifiers (<code>private</code>, <code>public</code>) to control access to data members.</li>
                <li><strong>Member Functions</strong>: Define the behavior of objects and can manipulate the object's data.</li>
                <li><strong>Structure vs. Class</strong>: Structures are simpler and primarily for data storage, while classes are used for OOP with data and behavior.</li>
                <li><strong>Memory Allocation</strong>: Objects are allocated memory when created, and their data members store the state.</li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">8. Additional Notes</h3>
            <ul class="list-disc ml-6">
                <li><strong>Access Specifiers</strong>:
                    <ul class="list-circle ml-6">
                        <li><code>public</code>: Members are accessible from outside the class.</li>
                        <li><code>private</code>: Members are accessible only within the class.</li>
                        <li><code>protected</code>: Members are accessible within the class and its derived classes (relevant for inheritance, not covered in this unit).</li>
                    </ul>
                </li>
                <li><strong>Constructors and Destructors</strong>:
                    <ul class="list-circle ml-6">
                        <li>A <strong>constructor</strong> is automatically called when an object is created.</li>
                        <li>A <strong>destructor</strong> (e.g., <code>~Car()</code>) is called when an object goes out of scope to clean up resources.</li>
                    </ul>
                </li>
                <li><strong>Best Practices</strong>:
                    <ul class="list-circle ml-6">
                        <li>Use <code>private</code> for data members to ensure encapsulation.</li>
                        <li>Provide public member functions (getters/setters) to access or modify private data.</li>
                        <li>Use meaningful names for classes, data members, and member functions.</li>
                    </ul>
                </li>
            </ul>

            <hr class="my-6 border-t border-gray-300">

            <h3 class="text-lg md:text-xl">9. Conclusion</h3>
            <p>The concept of classes and objects is fundamental to OOP in C++. Classes provide a way to model real-world entities by combining data and functions, while objects allow the instantiation of these models. Member functions enable objects to exhibit behavior, and the distinction between structures and classes highlights the power of classes in implementing OOP principles. The example provided demonstrates how to create a class, define member functions, and use objects effectively, laying the foundation for more advanced OOP concepts like inheritance and polymorphism.</p>

            <hr class="my-6 border-t border-gray-300">

            <p>This note covers the syllabus topics comprehensively, with clear explanations and a practical example to illustrate the concepts of objects, classes, and member functions in C++.</p>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const hamburgerIcon = document.getElementById('hamburger-icon');
            const overlay = document.getElementById('overlay');
            const overlayLinks = document.querySelectorAll('.overlay-menu a');

            // Function to open the overlay menu
            hamburgerIcon.addEventListener('click', () => {
                overlay.classList.toggle('open');
                hamburgerIcon.classList.toggle('open');
            });

            // Function to close the overlay menu when a link is clicked
            window.closeOverlay = () => {
                overlay.classList.remove('open');
                hamburgerIcon.classList.remove('open');
            };

            // Optional: Close overlay if clicked outside the menu (on the dark background)
            overlay.addEventListener('click', (event) => {
                if (event.target === overlay) {
                    closeOverlay();
                }
            });

            // Highlight active unit in navigation
            const highlightActiveUnit = () => {
                const currentHash = window.location.hash;
                overlayLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === currentHash) {
                        link.classList.add('active');
                    }
                });
            };

            // Call on initial load
            highlightActiveUnit();

            // Call when hash changes (e.g., user clicks a navigation link)
            window.addEventListener('hashchange', highlightActiveUnit);
        });
    </script>
</body>
</html>
